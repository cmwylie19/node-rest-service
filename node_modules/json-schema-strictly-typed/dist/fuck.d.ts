import * as t from "io-ts";
export declare const JSSTEmpty: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTEmpty<U>, JSSTEmpty<U>, unknown>;
export declare const JSSTEmpty_: t.Type<JSSTEmpty<{}>, JSSTEmpty<{}>, unknown>;
export declare const JSSTList: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTList<T, U>, JSSTList<T, U>, unknown>;
export declare const JSSTList_: t.Type<JSSTList<JSSTEmpty<{}>, {}>, JSSTList<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTAnything: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTAnything<T, U>, JSSTAnything<T, U>, unknown>;
export declare const JSSTTuple: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTTuple<T, U>, JSSTTuple<T, U>, unknown>;
export declare const JSSTTuple_: t.Type<JSSTTuple<JSSTEmpty<{}>, {}>, JSSTTuple<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTObject: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTObject<T, U>, JSSTObject<T, U>, unknown>;
export declare const JSSTObject_: t.Type<JSSTObject<JSSTEmpty<{}>, {}>, JSSTObject<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTOneOf: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTOneOf<T, U>, JSSTOneOf<T, U>, unknown>;
export declare const JSSTOneOf_: t.Type<JSSTOneOf<JSSTEmpty<{}>, {}>, JSSTOneOf<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTAnyOf: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTAnyOf<T, U>, JSSTAnyOf<T, U>, unknown>;
export declare const JSSTAnyOf_: t.Type<JSSTAnyOf<JSSTEmpty<{}>, {}>, JSSTAnyOf<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTAllOf: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTAllOf<T, U>, JSSTAllOf<T, U>, unknown>;
export declare const JSSTAllOf_: t.Type<JSSTAllOf<JSSTEmpty<{}>, {}>, JSSTAllOf<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTNot: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTNot<T, U>, JSSTNot<T, U>, unknown>;
export declare const JSSTNot_: t.Type<JSSTNot<JSSTEmpty<{}>, {}>, JSSTNot<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSONPrimitive: t.UnionC<[t.NumberC, t.BooleanC, t.StringC, t.NullC]>;
export declare const JSONValue: t.Type<JSONValue>;
export declare const JSONObject: t.Type<JSONObject>;
export declare const JSONArray: t.Type<JSONArray>;
export declare const JSSTConst: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTConst<U>, JSSTConst<U>, unknown>;
export declare const JSSTConst_: t.Type<JSSTConst<{}>, JSSTConst<{}>, unknown>;
export declare const JSSTReference: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTReference<U>, JSSTReference<U>, unknown>;
export declare const JSSTReference_: t.Type<JSSTReference<{}>, JSSTReference<{}>, unknown>;
export declare const JSSTNull: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTNull<U>, JSSTNull<U>, unknown>;
export declare const JSSTNull_: t.Type<JSSTNull<{}>, JSSTNull<{}>, unknown>;
export declare const JSSTBoolean: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTBoolean<U>, JSSTBoolean<U>, unknown>;
export declare const JSSTBoolean_: t.Type<JSSTBoolean<{}>, JSSTBoolean<{}>, unknown>;
export declare const JSSTProtoInteger: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTProtoInteger<U>, JSSTProtoInteger<U>, unknown>;
export declare const JSSTSimpleInteger: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleInteger<U>, JSSTSimpleInteger<U>, unknown>;
export declare const JSSTSimpleInteger_: t.Type<JSSTSimpleInteger<{}>, JSSTSimpleInteger<{}>, unknown>;
export declare const JSSTIntegerWithMinimum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithMinimum<U>, JSSTIntegerWithMinimum<U>, unknown>;
export declare const JSSTIntegerWithMinimum_: t.Type<JSSTIntegerWithMinimum<{}>, JSSTIntegerWithMinimum<{}>, unknown>;
export declare const JSSTIntegerWithMaximum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithMaximum<U>, JSSTIntegerWithMaximum<U>, unknown>;
export declare const JSSTIntegerWithMaximum_: t.Type<JSSTIntegerWithMaximum<{}>, JSSTIntegerWithMaximum<{}>, unknown>;
export declare const JSSTIntegerWithBounds: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithBounds<U>, JSSTIntegerWithBounds<U>, unknown>;
export declare const JSSTIntegerWithBounds_: t.Type<JSSTIntegerWithBounds<{}>, JSSTIntegerWithBounds<{}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMinimum<U>, JSSTIntegerWithNumericExclusiveMinimum<U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimum_: t.Type<JSSTIntegerWithNumericExclusiveMinimum<{}>, JSSTIntegerWithNumericExclusiveMinimum<{}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMinimumAndMaximum<U>, JSSTIntegerWithNumericExclusiveMinimumAndMaximum<U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximum_: t.Type<JSSTIntegerWithNumericExclusiveMinimumAndMaximum<{}>, JSSTIntegerWithNumericExclusiveMinimumAndMaximum<{}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMaximum<U>, JSSTIntegerWithNumericExclusiveMaximum<U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximum_: t.Type<JSSTIntegerWithNumericExclusiveMaximum<{}>, JSSTIntegerWithNumericExclusiveMaximum<{}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMaximumAndMinimum<U>, JSSTIntegerWithNumericExclusiveMaximumAndMinimum<U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimum_: t.Type<JSSTIntegerWithNumericExclusiveMaximumAndMinimum<{}>, JSSTIntegerWithNumericExclusiveMaximumAndMinimum<{}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveBounds: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveBounds<U>, JSSTIntegerWithNumericExclusiveBounds<U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveBounds_: t.Type<JSSTIntegerWithNumericExclusiveBounds<{}>, JSSTIntegerWithNumericExclusiveBounds<{}>, unknown>;
export declare const JSSTIntegerEnum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerEnum<U>, JSSTIntegerEnum<U>, unknown>;
export declare const JSSTIntegerEnum_: t.Type<JSSTIntegerEnum<{}>, JSSTIntegerEnum<{}>, unknown>;
export declare const JSSTInteger: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTInteger<U>, JSSTInteger<U>, unknown>;
export declare const JSSTInteger_: t.Type<JSSTInteger<{}>, JSSTInteger<{}>, unknown>;
export declare const JSSTProtoNumber: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTProtoNumber<U>, JSSTProtoNumber<U>, unknown>;
export declare const JSSTProtoNumber_: t.Type<JSSTProtoNumber<{}>, JSSTProtoNumber<{}>, unknown>;
export declare const JSSTSimpleNumber: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleNumber<U>, JSSTSimpleNumber<U>, unknown>;
export declare const JSSTSimpleNumber_: t.Type<JSSTSimpleNumber<{}>, JSSTSimpleNumber<{}>, unknown>;
export declare const JSSTNumberEnum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTNumberEnum<U>, JSSTNumberEnum<U>, unknown>;
export declare const JSSTNumberEnum_: t.Type<JSSTNumberEnum<{}>, JSSTNumberEnum<{}>, unknown>;
export declare const JSSTNumber: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTNumber<U>, JSSTNumber<U>, unknown>;
export declare const JSSTNumber_: t.Type<JSSTNumber<{}>, JSSTNumber<{}>, unknown>;
export declare const JSSTProtoString: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTProtoString<U>, JSSTProtoString<U>, unknown>;
export declare const JSSTFaker: t.UnionC<[t.LiteralC<"address.zipCode">, t.LiteralC<"address.city">, t.LiteralC<"address.cityPrefix">, t.LiteralC<"address.citySuffix">, t.LiteralC<"address.streetName">, t.LiteralC<"address.streetAddress">, t.LiteralC<"address.streetSuffix">, t.LiteralC<"address.streetPrefix">, t.LiteralC<"address.secondaryAddress">, t.LiteralC<"address.county">, t.LiteralC<"address.country">, t.LiteralC<"address.countryCode">, t.LiteralC<"address.state">, t.LiteralC<"address.stateAbbr">, t.LiteralC<"address.latitude">, t.LiteralC<"address.longitude">, t.LiteralC<"commerce.color">, t.LiteralC<"commerce.department">, t.LiteralC<"commerce.productName">, t.LiteralC<"commerce.price">, t.LiteralC<"commerce.productAdjective">, t.LiteralC<"commerce.productMaterial">, t.LiteralC<"commerce.product">, t.LiteralC<"company.suffixes">, t.LiteralC<"company.companyName">, t.LiteralC<"company.companySuffix">, t.LiteralC<"company.catchPhrase">, t.LiteralC<"company.bs">, t.LiteralC<"company.catchPhraseAdjective">, t.LiteralC<"company.catchPhraseDescriptor">, t.LiteralC<"company.catchPhraseNoun">, t.LiteralC<"company.bsAdjective">, t.LiteralC<"company.bsBuzz">, t.LiteralC<"company.bsNoun">, t.LiteralC<"database.column">, t.LiteralC<"database.type">, t.LiteralC<"database.collation">, t.LiteralC<"database.engine">, t.LiteralC<"date.past">, t.LiteralC<"date.future">, t.LiteralC<"date.between">, t.LiteralC<"date.recent">, t.LiteralC<"date.soon">, t.LiteralC<"date.month">, t.LiteralC<"date.weekday">, t.LiteralC<"finance.account">, t.LiteralC<"finance.accountName">, t.LiteralC<"finance.mask">, t.LiteralC<"finance.amount">, t.LiteralC<"finance.transactionType">, t.LiteralC<"finance.currencyCode">, t.LiteralC<"finance.currencyName">, t.LiteralC<"finance.currencySymbol">, t.LiteralC<"finance.bitcoinAddress">, t.LiteralC<"finance.ethereumAddress">, t.LiteralC<"finance.iban">, t.LiteralC<"finance.bic">, t.LiteralC<"hacker.abbreviation">, t.LiteralC<"hacker.adjective">, t.LiteralC<"hacker.noun">, t.LiteralC<"hacker.verb">, t.LiteralC<"hacker.ingverb">, t.LiteralC<"hacker.phrase">, t.LiteralC<"helpers.randomize">, t.LiteralC<"helpers.slugify">, t.LiteralC<"helpers.replaceSymbolWithNumber">, t.LiteralC<"helpers.replaceSymbols">, t.LiteralC<"helpers.shuffle">, t.LiteralC<"helpers.mustache">, t.LiteralC<"helpers.createCard">, t.LiteralC<"helpers.contextualCard">, t.LiteralC<"helpers.userCard">, t.LiteralC<"helpers.createTransaction">, t.LiteralC<"image.image">, t.LiteralC<"image.avatar">, t.LiteralC<"image.imageUrl">, t.LiteralC<"image.abstract">, t.LiteralC<"image.animals">, t.LiteralC<"image.business">, t.LiteralC<"image.cats">, t.LiteralC<"image.city">, t.LiteralC<"image.food">, t.LiteralC<"image.nightlife">, t.LiteralC<"image.fashion">, t.LiteralC<"image.people">, t.LiteralC<"image.nature">, t.LiteralC<"image.sports">, t.LiteralC<"image.technics">, t.LiteralC<"image.transport">, t.LiteralC<"image.dataUri">, t.LiteralC<"internet.avatar">, t.LiteralC<"internet.email">, t.LiteralC<"internet.exampleEmail">, t.LiteralC<"internet.userName">, t.LiteralC<"internet.protocol">, t.LiteralC<"internet.url">, t.LiteralC<"internet.domainName">, t.LiteralC<"internet.domainSuffix">, t.LiteralC<"internet.domainWord">, t.LiteralC<"internet.ip">, t.LiteralC<"internet.ipv6">, t.LiteralC<"internet.userAgent">, t.LiteralC<"internet.color">, t.LiteralC<"internet.mac">, t.LiteralC<"internet.password">, t.LiteralC<"lorem.word">, t.LiteralC<"lorem.words">, t.LiteralC<"lorem.sentence">, t.LiteralC<"lorem.slug">, t.LiteralC<"lorem.sentences">, t.LiteralC<"lorem.paragraph">, t.LiteralC<"lorem.paragraphs">, t.LiteralC<"lorem.text">, t.LiteralC<"lorem.lines">, t.LiteralC<"name.firstName">, t.LiteralC<"name.lastName">, t.LiteralC<"name.findName">, t.LiteralC<"name.jobTitle">, t.LiteralC<"name.prefix">, t.LiteralC<"name.suffix">, t.LiteralC<"name.title">, t.LiteralC<"name.jobDescriptor">, t.LiteralC<"name.jobArea">, t.LiteralC<"name.jobType">, t.LiteralC<"phone.phoneNumber">, t.LiteralC<"phone.phoneNumberFormat">, t.LiteralC<"phone.phoneFormats">, t.LiteralC<"random.number">, t.LiteralC<"random.float">, t.LiteralC<"random.arrayElement">, t.LiteralC<"random.objectElement">, t.LiteralC<"random.uuid">, t.LiteralC<"random.boolean">, t.LiteralC<"random.word">, t.LiteralC<"random.words">, t.LiteralC<"random.image">, t.LiteralC<"random.locale">, t.LiteralC<"random.alphaNumeric">, t.LiteralC<"random.hexaDecimal">, t.LiteralC<"system.fileName">, t.LiteralC<"system.commonFileName">, t.LiteralC<"system.mimeType">, t.LiteralC<"system.commonFileType">, t.LiteralC<"system.commonFileExt">, t.LiteralC<"system.fileType">, t.LiteralC<"system.fileExt">, t.LiteralC<"system.directoryPath">, t.LiteralC<"system.filePath">, t.LiteralC<"system.semver">]>;
export declare const JSSTProtoString_: t.Type<JSSTProtoString<{}>, JSSTProtoString<{}>, unknown>;
export declare const JSSTSimpleString: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleString<U>, JSSTSimpleString<U>, unknown>;
export declare const JSSTSimpleString_: t.Type<JSSTSimpleString<{}>, JSSTSimpleString<{}>, unknown>;
export declare const JSSTRegex: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTRegex<U>, JSSTRegex<U>, unknown>;
export declare const JSSTRegex_: t.Type<JSSTRegex<{}>, JSSTRegex<{}>, unknown>;
export declare const JSSTStringEnum: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTStringEnum<U>, JSSTStringEnum<U>, unknown>;
export declare const JSSTStringEnum_: t.Type<JSSTStringEnum<{}>, JSSTStringEnum<{}>, unknown>;
export declare const JSSTString: <U extends object>(u: t.Type<U, U, unknown>) => t.Type<JSSTString<U>, JSSTString<U>, unknown>;
export declare const JSSTString_: t.Type<JSSTString<{}>, JSSTString<{}>, unknown>;
export declare const JSSTProtoArray: t.TypeC<{
    type: t.LiteralC<"array">;
}>;
export declare const JSSTArray: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTArray<T, U>, JSSTArray<T, U>, unknown>;
export declare const JSSTArray_: t.Type<JSSTArray<JSSTEmpty<{}>, {}>, JSSTArray<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTTopLevel<T, U>, JSSTTopLevel<T, U>, unknown>;
export declare const JSSTTopLevel_: t.Type<JSSTTopLevel<JSSTEmpty<{}>, {}>, JSSTTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTEmptyTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTEmptyTopLevel<T, U>, JSSTEmptyTopLevel<T, U>, unknown>;
export declare const JSSTEmptyTopLevel_: t.Type<JSSTEmptyTopLevel<JSSTEmpty<{}>, {}>, JSSTEmptyTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTConstTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTConstTopLevel<T, U>, JSSTConstTopLevel<T, U>, unknown>;
export declare const JSSTConstTopLevel_: t.Type<JSSTConstTopLevel<JSSTEmpty<{}>, {}>, JSSTConstTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTReferenceTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTReferenceTopLevel<T, U>, JSSTReferenceTopLevel<T, U>, unknown>;
export declare const JSSTReferenceTopLevel_: t.Type<JSSTReferenceTopLevel<JSSTEmpty<{}>, {}>, JSSTReferenceTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTNullTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTNullTopLevel<T, U>, JSSTNullTopLevel<T, U>, unknown>;
export declare const JSSTNullTopLevel_: t.Type<JSSTNullTopLevel<JSSTEmpty<{}>, {}>, JSSTNullTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTBooleanTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTBooleanTopLevel<T, U>, JSSTBooleanTopLevel<T, U>, unknown>;
export declare const JSSTBooleanTopLevel_: t.Type<JSSTBooleanTopLevel<JSSTEmpty<{}>, {}>, JSSTBooleanTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerTopLevel<T, U>, JSSTIntegerTopLevel<T, U>, unknown>;
export declare const JSSTIntegerTopLevel_: t.Type<JSSTIntegerTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTSimpleIntegerTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleIntegerTopLevel<T, U>, JSSTSimpleIntegerTopLevel<T, U>, unknown>;
export declare const JSSTSimpleIntegerTopLevel_: t.Type<JSSTSimpleIntegerTopLevel<JSSTEmpty<{}>, {}>, JSSTSimpleIntegerTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithMinimumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithMinimumTopLevel<T, U>, JSSTIntegerWithMinimumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithMinimumTopLevelTopLevel_: t.Type<JSSTIntegerWithMinimumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithMinimumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithMaximumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithMaximumTopLevel<T, U>, JSSTIntegerWithMaximumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithMaximumTopLevel_: t.Type<JSSTIntegerWithMaximumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithMaximumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithBoundsTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithBoundsTopLevel<T, U>, JSSTIntegerWithBoundsTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithBoundsTopLevel_: t.Type<JSSTIntegerWithBoundsTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithBoundsTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMinimumTopLevel<T, U>, JSSTIntegerWithNumericExclusiveMinimumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumTopLevel_: t.Type<JSSTIntegerWithNumericExclusiveMinimumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithNumericExclusiveMinimumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<T, U>, JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel_: t.Type<JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMaximumTopLevel<T, U>, JSSTIntegerWithNumericExclusiveMaximumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumTopLevel_: t.Type<JSSTIntegerWithNumericExclusiveMaximumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithNumericExclusiveMaximumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<T, U>, JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel_: t.Type<JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveBoundsTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerWithNumericExclusiveBoundsTopLevel<T, U>, JSSTIntegerWithNumericExclusiveBoundsTopLevel<T, U>, unknown>;
export declare const JSSTIntegerWithNumericExclusiveBoundsTopLevel_: t.Type<JSSTIntegerWithNumericExclusiveBoundsTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerWithNumericExclusiveBoundsTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTIntegerEnumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTIntegerEnumTopLevel<T, U>, JSSTIntegerEnumTopLevel<T, U>, unknown>;
export declare const JSSTIntegerEnumTopLevel_: t.Type<JSSTIntegerEnumTopLevel<JSSTEmpty<{}>, {}>, JSSTIntegerEnumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTNumberTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTNumberTopLevel<T, U>, JSSTNumberTopLevel<T, U>, unknown>;
export declare const JSSTNumberTopLevel_: t.Type<JSSTNumberTopLevel<JSSTEmpty<{}>, {}>, JSSTNumberTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTSimpleNumberTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleNumberTopLevel<T, U>, JSSTSimpleNumberTopLevel<T, U>, unknown>;
export declare const JSSTSimpleNumberTopLevel_: t.Type<JSSTSimpleNumberTopLevel<JSSTEmpty<{}>, {}>, JSSTSimpleNumberTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTNumberEnumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTNumberEnumTopLevel<T, U>, JSSTNumberEnumTopLevel<T, U>, unknown>;
export declare const JSSTNumberEnumTopLevel_: t.Type<JSSTNumberEnumTopLevel<JSSTEmpty<{}>, {}>, JSSTNumberEnumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTAnyOfTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTAnyOfTopLevel<T, U>, JSSTAnyOfTopLevel<T, U>, unknown>;
export declare const JSSTAnyOfTopLevel_: t.Type<JSSTAnyOfTopLevel<JSSTEmpty<{}>, {}>, JSSTAnyOfTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTAllOfTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTAllOfTopLevel<T, U>, JSSTAllOfTopLevel<T, U>, unknown>;
export declare const JSSTAllOfTopLevel_: t.Type<JSSTAllOfTopLevel<JSSTEmpty<{}>, {}>, JSSTAllOfTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTNotTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTNotTopLevel<T, U>, JSSTNotTopLevel<T, U>, unknown>;
export declare const JSSTNotTopLevel_: t.Type<JSSTNotTopLevel<JSSTEmpty<{}>, {}>, JSSTNotTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTOneOfTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTOneOfTopLevel<T, U>, JSSTOneOfTopLevel<T, U>, unknown>;
export declare const JSSTOneOfTopLevel_: t.Type<JSSTOneOfTopLevel<JSSTEmpty<{}>, {}>, JSSTOneOfTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTStringTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTStringTopLevel<T, U>, JSSTStringTopLevel<T, U>, unknown>;
export declare const JSSTStringTopLevel_: t.Type<JSSTStringTopLevel<JSSTEmpty<{}>, {}>, JSSTStringTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTSimpleStringTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTSimpleStringTopLevel<T, U>, JSSTSimpleStringTopLevel<T, U>, unknown>;
export declare const JSSTSimpleStringTopLevel_: t.Type<JSSTSimpleStringTopLevel<JSSTEmpty<{}>, {}>, JSSTSimpleStringTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTRegexTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTRegexTopLevel<T, U>, JSSTRegexTopLevel<T, U>, unknown>;
export declare const JSSTRegexTopLevel_: t.Type<JSSTRegexTopLevel<JSSTEmpty<{}>, {}>, JSSTRegexTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTStringEnumTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTStringEnumTopLevel<T, U>, JSSTStringEnumTopLevel<T, U>, unknown>;
export declare const JSSTStringEnumTopLevel_: t.Type<JSSTStringEnumTopLevel<JSSTEmpty<{}>, {}>, JSSTStringEnumTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTArrayTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTArrayTopLevel<T, U>, JSSTArrayTopLevel<T, U>, unknown>;
export declare const JSSTArrayTopLevel_: t.Type<JSSTArrayTopLevel<JSSTEmpty<{}>, {}>, JSSTArrayTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTListTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTListTopLevel<T, U>, JSSTListTopLevel<T, U>, unknown>;
export declare const JSSTListTopLevel_: t.Type<JSSTListTopLevel<JSSTEmpty<{}>, {}>, JSSTListTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTTupleTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTTupleTopLevel<T, U>, JSSTTupleTopLevel<T, U>, unknown>;
export declare const JSSTTupleTopLevel_: t.Type<JSSTTupleTopLevel<JSSTEmpty<{}>, {}>, JSSTTupleTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTObjectTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTObjectTopLevel<T, U>, JSSTObjectTopLevel<T, U>, unknown>;
export declare const JSSTObjectTopLevel_: t.Type<JSSTObjectTopLevel<JSSTEmpty<{}>, {}>, JSSTObjectTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSSTGenericTopLevel: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSSTGenericTopLevel<T, U>, JSSTGenericTopLevel<T, U>, unknown>;
export declare const JSSTGenericTopLevel_: t.Type<JSSTGenericTopLevel<JSSTEmpty<{}>, {}>, JSSTGenericTopLevel<JSSTEmpty<{}>, {}>, unknown>;
export declare const JSONSchemaObject: <T, U extends object>(c: t.Type<T, T, unknown>, u: t.Type<U, U, unknown>) => t.Type<JSONSchemaObject<T, U>, JSONSchemaObject<T, U>, unknown>;
export declare type JSSTList<T, U extends object> = JSSTProtoArray & {
    items: JSSTAnything<T, U>;
    uniqueItems?: boolean;
    minItems?: number;
    maxItems?: number;
} & U;
export declare type JSSTAnything<T, U extends object> = JSSTEmpty<U> | JSSTConst<U> | JSSTReference<U> | JSSTNull<U> | JSSTBoolean<U> | JSSTInteger<U> | JSSTNumber<U> | JSSTString<U> | JSSTArray<T, U> | JSSTObject<T, U> | JSSTOneOf<T, U> | JSSTAnyOf<T, U> | JSSTAllOf<T, U> | JSSTNot<T, U> | T;
export declare type JSSTTuple<T, U extends object> = JSSTProtoArray & {
    items: Array<JSSTAnything<T, U>>;
} & U;
export declare type JSSTObject<T, U extends object> = {
    type: "object";
    required?: Array<string>;
    dependencies?: Record<string, Array<string>>;
    additionalProperties?: boolean | JSSTAnything<T, U>;
    patternProperties?: Record<string, JSSTAnything<T, U>>;
    properties?: Record<string, JSSTAnything<T, U>>;
} & U;
export declare type JSSTOneOf<T, U extends object> = {
    oneOf: Array<JSSTAnything<T, U>>;
} & U;
export declare type JSSTAnyOf<T, U extends object> = {
    anyOf: Array<JSSTAnything<T, U>>;
} & U;
export declare type JSSTAllOf<T, U extends object> = {
    allOf: Array<JSSTAnything<T, U>>;
} & U;
export declare type JSSTNot<T, U extends object> = {
    not: JSSTAnything<T, U>;
} & U;
export declare type JSSTEmpty<U extends object> = {
    [k: string]: never;
    [z: number]: never;
} & U;
export declare type JSONPrimitive = number | boolean | string | null;
export declare type JSONValue = JSONPrimitive | JSONArray | JSONObject;
export declare type JSONObject = {
    [k: string]: JSONValue;
};
export interface JSONArray extends Array<JSONValue> {
}
export declare type JSSTConst<U extends object> = {
    const: JSONValue;
} & U;
export declare type JSSTReference<U extends object> = {
    $ref: string;
} & U;
export declare type JSSTNull<U extends object> = {
    type: "null";
} & U;
export declare type JSSTBoolean<U extends object> = {
    type: "boolean";
} & U;
export declare type JSSTProtoInteger<U extends object> = {
    type: "integer";
} & U;
export declare type JSSTSimpleInteger<U extends object> = JSSTProtoInteger<U> & {
    multipleOf?: number;
};
export declare type JSSTIntegerWithMinimum<U extends object> = JSSTSimpleInteger<U> & {
    minimum: number;
    exclusiveMinimum?: boolean;
};
export declare type JSSTIntegerWithMaximum<U extends object> = JSSTSimpleInteger<U> & {
    maximum: number;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithBounds<U extends object> = JSSTSimpleInteger<U> & {
    minimum: number;
    maximum: number;
    exclusiveMinimum?: boolean;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveMinimum<U extends object> = JSSTSimpleInteger<U> & {
    exclusiveMinimum: number;
};
export declare type JSSTIntegerWithNumericExclusiveMinimumAndMaximum<U extends object> = JSSTSimpleInteger<U> & {
    exclusiveMinimum: number;
    maximum: number;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveMaximum<U extends object> = JSSTSimpleInteger<U> & {
    exclusiveMaximum: number;
};
export declare type JSSTIntegerWithNumericExclusiveMaximumAndMinimum<U extends object> = JSSTSimpleInteger<U> & {
    exclusiveMaximum: number;
    minimum: number;
    exclusiveMinimum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveBounds<U extends object> = JSSTSimpleInteger<U> & {
    exclusiveMinimum: number;
    exclusiveMaximum: number;
};
export declare type JSSTIntegerEnum<U extends object> = JSSTProtoInteger<U> & {
    enum: Array<number>;
};
export declare type JSSTInteger<U extends object> = JSSTSimpleInteger<U> | JSSTIntegerWithMinimum<U> | JSSTIntegerWithMaximum<U> | JSSTIntegerWithBounds<U> | JSSTIntegerWithNumericExclusiveMinimum<U> | JSSTIntegerWithNumericExclusiveMinimumAndMaximum<U> | JSSTIntegerWithNumericExclusiveMaximum<U> | JSSTIntegerWithNumericExclusiveMaximumAndMinimum<U> | JSSTIntegerWithNumericExclusiveBounds<U> | JSSTIntegerEnum<U>;
export declare type JSSTProtoNumber<U extends object> = {
    type: "number";
} & U;
export declare type JSSTSimpleNumber<U extends object> = JSSTProtoNumber<U> & {
    minimum?: number;
    maximum?: number;
    multipleOf?: number;
};
export declare type JSSTNumberEnum<U extends object> = JSSTProtoNumber<U> & {
    enum: Array<number>;
};
export declare type JSSTNumber<U extends object> = JSSTSimpleNumber<U> | JSSTNumberEnum<U>;
export declare type JSSTProtoString<U extends object> = {
    type: "string";
} & U;
export declare type JSSTFaker = "address.zipCode" | "address.city" | "address.cityPrefix" | "address.citySuffix" | "address.streetName" | "address.streetAddress" | "address.streetSuffix" | "address.streetPrefix" | "address.secondaryAddress" | "address.county" | "address.country" | "address.countryCode" | "address.state" | "address.stateAbbr" | "address.latitude" | "address.longitude" | "commerce.color" | "commerce.department" | "commerce.productName" | "commerce.price" | "commerce.productAdjective" | "commerce.productMaterial" | "commerce.product" | "company.suffixes" | "company.companyName" | "company.companySuffix" | "company.catchPhrase" | "company.bs" | "company.catchPhraseAdjective" | "company.catchPhraseDescriptor" | "company.catchPhraseNoun" | "company.bsAdjective" | "company.bsBuzz" | "company.bsNoun" | "database.column" | "database.type" | "database.collation" | "database.engine" | "date.past" | "date.future" | "date.between" | "date.recent" | "date.soon" | "date.month" | "date.weekday" | "finance.account" | "finance.accountName" | "finance.mask" | "finance.amount" | "finance.transactionType" | "finance.currencyCode" | "finance.currencyName" | "finance.currencySymbol" | "finance.bitcoinAddress" | "finance.ethereumAddress" | "finance.iban" | "finance.bic" | "hacker.abbreviation" | "hacker.adjective" | "hacker.noun" | "hacker.verb" | "hacker.ingverb" | "hacker.phrase" | "helpers.randomize" | "helpers.slugify" | "helpers.replaceSymbolWithNumber" | "helpers.replaceSymbols" | "helpers.shuffle" | "helpers.mustache" | "helpers.createCard" | "helpers.contextualCard" | "helpers.userCard" | "helpers.createTransaction" | "image.image" | "image.avatar" | "image.imageUrl" | "image.abstract" | "image.animals" | "image.business" | "image.cats" | "image.city" | "image.food" | "image.nightlife" | "image.fashion" | "image.people" | "image.nature" | "image.sports" | "image.technics" | "image.transport" | "image.dataUri" | "internet.avatar" | "internet.email" | "internet.exampleEmail" | "internet.userName" | "internet.protocol" | "internet.url" | "internet.domainName" | "internet.domainSuffix" | "internet.domainWord" | "internet.ip" | "internet.ipv6" | "internet.userAgent" | "internet.color" | "internet.mac" | "internet.password" | "lorem.word" | "lorem.words" | "lorem.sentence" | "lorem.slug" | "lorem.sentences" | "lorem.paragraph" | "lorem.paragraphs" | "lorem.text" | "lorem.lines" | "name.firstName" | "name.lastName" | "name.findName" | "name.jobTitle" | "name.prefix" | "name.suffix" | "name.title" | "name.jobDescriptor" | "name.jobArea" | "name.jobType" | "phone.phoneNumber" | "phone.phoneNumberFormat" | "phone.phoneFormats" | "random.number" | "random.float" | "random.arrayElement" | "random.objectElement" | "random.uuid" | "random.boolean" | "random.word" | "random.words" | "random.image" | "random.locale" | "random.alphaNumeric" | "random.hexaDecimal" | "system.fileName" | "system.commonFileName" | "system.mimeType" | "system.commonFileType" | "system.commonFileExt" | "system.fileType" | "system.fileExt" | "system.directoryPath" | "system.filePath" | "system.semver";
export declare type JSSTSimpleString<U extends object> = JSSTProtoString<U> & {
    faker?: JSSTFaker;
};
export declare type JSSTRegex<U extends object> = JSSTProtoString<U> & {
    pattern: string;
};
export declare type JSSTStringEnum<U extends object> = JSSTProtoString<U> & {
    enum: Array<string>;
};
export declare type JSSTString<U extends object> = JSSTSimpleString<U> | JSSTRegex<U> | JSSTStringEnum<U>;
export interface JSSTProtoArray {
    type: "array";
}
export declare type JSSTArray<T, U extends object> = JSSTList<T, U> | JSSTTuple<T, U>;
export interface JSSTTopLevel<T, U extends object> {
    $schema?: string;
    $id?: string;
    definitions?: Record<string, JSSTAnything<T, U>>;
}
export declare type JSSTEmptyTopLevel<T, U extends object> = JSSTEmpty<U> & JSSTTopLevel<T, U>;
export declare type JSSTConstTopLevel<T, U extends object> = JSSTConst<U> & JSSTTopLevel<T, U>;
export declare type JSSTReferenceTopLevel<T, U extends object> = JSSTReference<U> & JSSTTopLevel<T, U>;
export declare type JSSTNullTopLevel<T, U extends object> = JSSTNull<U> & JSSTTopLevel<T, U>;
export declare type JSSTBooleanTopLevel<T, U extends object> = JSSTBoolean<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerTopLevel<T, U extends object> = JSSTInteger<U> & JSSTTopLevel<T, U>;
export declare type JSSTSimpleIntegerTopLevel<T, U extends object> = JSSTSimpleInteger<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithMinimumTopLevel<T, U extends object> = JSSTIntegerWithMinimum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithMaximumTopLevel<T, U extends object> = JSSTIntegerWithMaximum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithBoundsTopLevel<T, U extends object> = JSSTIntegerWithBounds<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithNumericExclusiveMinimumTopLevel<T, U extends object> = JSSTIntegerWithNumericExclusiveMinimum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<T, U extends object> = JSSTIntegerWithNumericExclusiveMinimumAndMaximum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithNumericExclusiveMaximumTopLevel<T, U extends object> = JSSTIntegerWithNumericExclusiveMaximum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<T, U extends object> = JSSTIntegerWithNumericExclusiveMaximumAndMinimum<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerWithNumericExclusiveBoundsTopLevel<T, U extends object> = JSSTIntegerWithNumericExclusiveBounds<U> & JSSTTopLevel<T, U>;
export declare type JSSTIntegerEnumTopLevel<T, U extends object> = JSSTIntegerEnum<U> & JSSTTopLevel<T, U>;
export declare type JSSTNumberTopLevel<T, U extends object> = JSSTNumber<U> & JSSTTopLevel<T, U>;
export declare type JSSTSimpleNumberTopLevel<T, U extends object> = JSSTSimpleNumber<U> & JSSTTopLevel<T, U>;
export declare type JSSTNumberEnumTopLevel<T, U extends object> = JSSTNumberEnum<U> & JSSTTopLevel<T, U>;
export declare type JSSTAnyOfTopLevel<T, U extends object> = JSSTAnyOf<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTAllOfTopLevel<T, U extends object> = JSSTAllOf<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTNotTopLevel<T, U extends object> = JSSTNot<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTOneOfTopLevel<T, U extends object> = JSSTOneOf<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTStringTopLevel<T, U extends object> = JSSTString<U> & JSSTTopLevel<T, U>;
export declare type JSSTSimpleStringTopLevel<T, U extends object> = JSSTSimpleString<U> & JSSTTopLevel<T, U>;
export declare type JSSTRegexTopLevel<T, U extends object> = JSSTRegex<U> & JSSTTopLevel<T, U>;
export declare type JSSTStringEnumTopLevel<T, U extends object> = JSSTStringEnum<U> & JSSTTopLevel<T, U>;
export declare type JSSTArrayTopLevel<T, U extends object> = JSSTArray<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTListTopLevel<T, U extends object> = JSSTList<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTTupleTopLevel<T, U extends object> = JSSTTuple<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTObjectTopLevel<T, U extends object> = JSSTObject<T, U> & JSSTTopLevel<T, U>;
export declare type JSSTGenericTopLevel<T, U extends object> = T & JSSTTopLevel<T, U>;
export declare type JSONSchemaObject<T, U extends object> = JSSTEmptyTopLevel<T, U> | JSSTConstTopLevel<T, U> | JSSTReferenceTopLevel<T, U> | JSSTNullTopLevel<T, U> | JSSTBooleanTopLevel<T, U> | JSSTIntegerTopLevel<T, U> | JSSTSimpleIntegerTopLevel<T, U> | JSSTIntegerWithMinimumTopLevel<T, U> | JSSTIntegerWithMaximumTopLevel<T, U> | JSSTIntegerWithBoundsTopLevel<T, U> | JSSTIntegerWithNumericExclusiveMinimumTopLevel<T, U> | JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel<T, U> | JSSTIntegerWithNumericExclusiveMaximumTopLevel<T, U> | JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel<T, U> | JSSTIntegerWithNumericExclusiveBoundsTopLevel<T, U> | JSSTIntegerEnumTopLevel<T, U> | JSSTNumberTopLevel<T, U> | JSSTSimpleNumberTopLevel<T, U> | JSSTNumberEnumTopLevel<T, U> | JSSTAnyOfTopLevel<T, U> | JSSTAllOfTopLevel<T, U> | JSSTNotTopLevel<T, U> | JSSTOneOfTopLevel<T, U> | JSSTStringTopLevel<T, U> | JSSTSimpleStringTopLevel<T, U> | JSSTRegexTopLevel<T, U> | JSSTStringEnumTopLevel<T, U> | JSSTArrayTopLevel<T, U> | JSSTListTopLevel<T, U> | JSSTTupleTopLevel<T, U> | JSSTObjectTopLevel<T, U> | JSSTGenericTopLevel<T, U>;
//# sourceMappingURL=fuck.d.ts.map