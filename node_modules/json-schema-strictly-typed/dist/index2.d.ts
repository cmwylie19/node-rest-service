import * as t from "io-ts";
export declare const JSSTList: t.Type<JSSTList, JSSTListOutput>;
export declare const JSSTAnything: t.Type<JSSTAnything, JSSTAnythingOutput>;
export declare const JSSTTuple: t.Type<JSSTTuple, JSSTTupleOutput>;
export declare const JSSTObject: t.Type<JSSTObject, JSSTObjectOutput>;
export declare const JSSTOneOf: t.Type<JSSTOneOf, JSSTOneOfOutput>;
export declare const JSSTAnyOf: t.Type<JSSTAnyOf, JSSTAnyOfOutput>;
export declare const JSSTAllOf: t.Type<JSSTAllOf, JSSTAllOfOutput>;
export declare const JSSTNot: t.Type<JSSTNot, JSSTNotOutput>;
export declare const JSSTEmpty: t.TypeC<{}>;
export declare const JSSTConst: t.TypeC<{
    const: t.UnionC<[t.NumberC, t.NumberC, t.StringC, t.BooleanC, t.NullC, t.ArrayC<t.StringC>, t.TypeC<{}>]>;
}>;
export declare const JSSTReference: t.TypeC<{
    $ref: t.StringC;
}>;
export declare const JSSTNull: t.TypeC<{
    type: t.LiteralC<"null">;
}>;
export declare const JSSTBoolean: t.TypeC<{
    type: t.LiteralC<"boolean">;
}>;
export declare const JSSTProtoInteger: t.TypeC<{
    type: t.LiteralC<"integer">;
}>;
export declare const JSSTSimpleInteger: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>;
export declare const JSSTIntegerWithMinimum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>;
export declare const JSSTIntegerWithMaximum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>;
export declare const JSSTIntegerWithBounds: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
    exclusiveMaximum: t.BooleanC;
}>]>]>;
export declare const JSSTIntegerWithNumericExclusiveMinimum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMinimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>;
export declare const JSSTIntegerWithNumericExclusiveMaximum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMaximum: t.NumberC;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimum: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMaximum: t.NumberC;
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>;
export declare const JSSTIntegerWithNumericExclusiveBounds: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
    exclusiveMaximum: t.NumberC;
}>]>;
export declare const JSSTIntegerEnum: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>;
export declare const JSSTInteger: t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMinimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMaximum: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMaximum: t.NumberC;
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
    exclusiveMaximum: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>]>;
export declare const JSSTProtoNumber: t.TypeC<{
    type: t.LiteralC<"number">;
}>;
export declare const JSSTSimpleNumber: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.PartialC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
    multipleOf: t.NumberC;
}>]>;
export declare const JSSTNumberEnum: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>;
export declare const JSSTNumber: t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.PartialC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>]>;
export declare const JSSTProtoString: t.TypeC<{
    type: t.LiteralC<"string">;
}>;
export declare const JSSTSimpleString: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.PartialC<{
    faker: t.UnionC<[t.LiteralC<"address.zipCode">, t.LiteralC<"address.city">, t.LiteralC<"address.cityPrefix">, t.LiteralC<"address.citySuffix">, t.LiteralC<"address.streetName">, t.LiteralC<"address.streetAddress">, t.LiteralC<"address.streetSuffix">, t.LiteralC<"address.streetPrefix">, t.LiteralC<"address.secondaryAddress">, t.LiteralC<"address.county">, t.LiteralC<"address.country">, t.LiteralC<"address.countryCode">, t.LiteralC<"address.state">, t.LiteralC<"address.stateAbbr">, t.LiteralC<"address.latitude">, t.LiteralC<"address.longitude">, t.LiteralC<"commerce.color">, t.LiteralC<"commerce.department">, t.LiteralC<"commerce.productName">, t.LiteralC<"commerce.price">, t.LiteralC<"commerce.productAdjective">, t.LiteralC<"commerce.productMaterial">, t.LiteralC<"commerce.product">, t.LiteralC<"company.suffixes">, t.LiteralC<"company.companyName">, t.LiteralC<"company.companySuffix">, t.LiteralC<"company.catchPhrase">, t.LiteralC<"company.bs">, t.LiteralC<"company.catchPhraseAdjective">, t.LiteralC<"company.catchPhraseDescriptor">, t.LiteralC<"company.catchPhraseNoun">, t.LiteralC<"company.bsAdjective">, t.LiteralC<"company.bsBuzz">, t.LiteralC<"company.bsNoun">, t.LiteralC<"database.column">, t.LiteralC<"database.type">, t.LiteralC<"database.collation">, t.LiteralC<"database.engine">, t.LiteralC<"date.past">, t.LiteralC<"date.future">, t.LiteralC<"date.between">, t.LiteralC<"date.recent">, t.LiteralC<"date.soon">, t.LiteralC<"date.month">, t.LiteralC<"date.weekday">, t.LiteralC<"finance.account">, t.LiteralC<"finance.accountName">, t.LiteralC<"finance.mask">, t.LiteralC<"finance.amount">, t.LiteralC<"finance.transactionType">, t.LiteralC<"finance.currencyCode">, t.LiteralC<"finance.currencyName">, t.LiteralC<"finance.currencySymbol">, t.LiteralC<"finance.bitcoinAddress">, t.LiteralC<"finance.ethereumAddress">, t.LiteralC<"finance.iban">, t.LiteralC<"finance.bic">, t.LiteralC<"hacker.abbreviation">, t.LiteralC<"hacker.adjective">, t.LiteralC<"hacker.noun">, t.LiteralC<"hacker.verb">, t.LiteralC<"hacker.ingverb">, t.LiteralC<"hacker.phrase">, t.LiteralC<"helpers.randomize">, t.LiteralC<"helpers.slugify">, t.LiteralC<"helpers.replaceSymbolWithNumber">, t.LiteralC<"helpers.replaceSymbols">, t.LiteralC<"helpers.shuffle">, t.LiteralC<"helpers.mustache">, t.LiteralC<"helpers.createCard">, t.LiteralC<"helpers.contextualCard">, t.LiteralC<"helpers.userCard">, t.LiteralC<"helpers.createTransaction">, t.LiteralC<"image.image">, t.LiteralC<"image.avatar">, t.LiteralC<"image.imageUrl">, t.LiteralC<"image.abstract">, t.LiteralC<"image.animals">, t.LiteralC<"image.business">, t.LiteralC<"image.cats">, t.LiteralC<"image.city">, t.LiteralC<"image.food">, t.LiteralC<"image.nightlife">, t.LiteralC<"image.fashion">, t.LiteralC<"image.people">, t.LiteralC<"image.nature">, t.LiteralC<"image.sports">, t.LiteralC<"image.technics">, t.LiteralC<"image.transport">, t.LiteralC<"image.dataUri">, t.LiteralC<"internet.avatar">, t.LiteralC<"internet.email">, t.LiteralC<"internet.exampleEmail">, t.LiteralC<"internet.userName">, t.LiteralC<"internet.protocol">, t.LiteralC<"internet.url">, t.LiteralC<"internet.domainName">, t.LiteralC<"internet.domainSuffix">, t.LiteralC<"internet.domainWord">, t.LiteralC<"internet.ip">, t.LiteralC<"internet.ipv6">, t.LiteralC<"internet.userAgent">, t.LiteralC<"internet.color">, t.LiteralC<"internet.mac">, t.LiteralC<"internet.password">, t.LiteralC<"lorem.word">, t.LiteralC<"lorem.words">, t.LiteralC<"lorem.sentence">, t.LiteralC<"lorem.slug">, t.LiteralC<"lorem.sentences">, t.LiteralC<"lorem.paragraph">, t.LiteralC<"lorem.paragraphs">, t.LiteralC<"lorem.text">, t.LiteralC<"lorem.lines">, t.LiteralC<"name.firstName">, t.LiteralC<"name.lastName">, t.LiteralC<"name.findName">, t.LiteralC<"name.jobTitle">, t.LiteralC<"name.prefix">, t.LiteralC<"name.suffix">, t.LiteralC<"name.title">, t.LiteralC<"name.jobDescriptor">, t.LiteralC<"name.jobArea">, t.LiteralC<"name.jobType">, t.LiteralC<"phone.phoneNumber">, t.LiteralC<"phone.phoneNumberFormat">, t.LiteralC<"phone.phoneFormats">, t.LiteralC<"random.number">, t.LiteralC<"random.float">, t.LiteralC<"random.arrayElement">, t.LiteralC<"random.objectElement">, t.LiteralC<"random.uuid">, t.LiteralC<"random.boolean">, t.LiteralC<"random.word">, t.LiteralC<"random.words">, t.LiteralC<"random.image">, t.LiteralC<"random.locale">, t.LiteralC<"random.alphaNumeric">, t.LiteralC<"random.hexaDecimal">, t.LiteralC<"system.fileName">, t.LiteralC<"system.commonFileName">, t.LiteralC<"system.mimeType">, t.LiteralC<"system.commonFileType">, t.LiteralC<"system.commonFileExt">, t.LiteralC<"system.fileType">, t.LiteralC<"system.fileExt">, t.LiteralC<"system.directoryPath">, t.LiteralC<"system.filePath">, t.LiteralC<"system.semver">]>;
}>]>;
export declare const JSSTRegex: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    pattern: t.StringC;
}>]>;
export declare const JSSTStringEnum: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    enum: t.ArrayC<t.StringC>;
}>]>;
export declare const JSSTString: t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.PartialC<{
    faker: t.UnionC<[t.LiteralC<"address.zipCode">, t.LiteralC<"address.city">, t.LiteralC<"address.cityPrefix">, t.LiteralC<"address.citySuffix">, t.LiteralC<"address.streetName">, t.LiteralC<"address.streetAddress">, t.LiteralC<"address.streetSuffix">, t.LiteralC<"address.streetPrefix">, t.LiteralC<"address.secondaryAddress">, t.LiteralC<"address.county">, t.LiteralC<"address.country">, t.LiteralC<"address.countryCode">, t.LiteralC<"address.state">, t.LiteralC<"address.stateAbbr">, t.LiteralC<"address.latitude">, t.LiteralC<"address.longitude">, t.LiteralC<"commerce.color">, t.LiteralC<"commerce.department">, t.LiteralC<"commerce.productName">, t.LiteralC<"commerce.price">, t.LiteralC<"commerce.productAdjective">, t.LiteralC<"commerce.productMaterial">, t.LiteralC<"commerce.product">, t.LiteralC<"company.suffixes">, t.LiteralC<"company.companyName">, t.LiteralC<"company.companySuffix">, t.LiteralC<"company.catchPhrase">, t.LiteralC<"company.bs">, t.LiteralC<"company.catchPhraseAdjective">, t.LiteralC<"company.catchPhraseDescriptor">, t.LiteralC<"company.catchPhraseNoun">, t.LiteralC<"company.bsAdjective">, t.LiteralC<"company.bsBuzz">, t.LiteralC<"company.bsNoun">, t.LiteralC<"database.column">, t.LiteralC<"database.type">, t.LiteralC<"database.collation">, t.LiteralC<"database.engine">, t.LiteralC<"date.past">, t.LiteralC<"date.future">, t.LiteralC<"date.between">, t.LiteralC<"date.recent">, t.LiteralC<"date.soon">, t.LiteralC<"date.month">, t.LiteralC<"date.weekday">, t.LiteralC<"finance.account">, t.LiteralC<"finance.accountName">, t.LiteralC<"finance.mask">, t.LiteralC<"finance.amount">, t.LiteralC<"finance.transactionType">, t.LiteralC<"finance.currencyCode">, t.LiteralC<"finance.currencyName">, t.LiteralC<"finance.currencySymbol">, t.LiteralC<"finance.bitcoinAddress">, t.LiteralC<"finance.ethereumAddress">, t.LiteralC<"finance.iban">, t.LiteralC<"finance.bic">, t.LiteralC<"hacker.abbreviation">, t.LiteralC<"hacker.adjective">, t.LiteralC<"hacker.noun">, t.LiteralC<"hacker.verb">, t.LiteralC<"hacker.ingverb">, t.LiteralC<"hacker.phrase">, t.LiteralC<"helpers.randomize">, t.LiteralC<"helpers.slugify">, t.LiteralC<"helpers.replaceSymbolWithNumber">, t.LiteralC<"helpers.replaceSymbols">, t.LiteralC<"helpers.shuffle">, t.LiteralC<"helpers.mustache">, t.LiteralC<"helpers.createCard">, t.LiteralC<"helpers.contextualCard">, t.LiteralC<"helpers.userCard">, t.LiteralC<"helpers.createTransaction">, t.LiteralC<"image.image">, t.LiteralC<"image.avatar">, t.LiteralC<"image.imageUrl">, t.LiteralC<"image.abstract">, t.LiteralC<"image.animals">, t.LiteralC<"image.business">, t.LiteralC<"image.cats">, t.LiteralC<"image.city">, t.LiteralC<"image.food">, t.LiteralC<"image.nightlife">, t.LiteralC<"image.fashion">, t.LiteralC<"image.people">, t.LiteralC<"image.nature">, t.LiteralC<"image.sports">, t.LiteralC<"image.technics">, t.LiteralC<"image.transport">, t.LiteralC<"image.dataUri">, t.LiteralC<"internet.avatar">, t.LiteralC<"internet.email">, t.LiteralC<"internet.exampleEmail">, t.LiteralC<"internet.userName">, t.LiteralC<"internet.protocol">, t.LiteralC<"internet.url">, t.LiteralC<"internet.domainName">, t.LiteralC<"internet.domainSuffix">, t.LiteralC<"internet.domainWord">, t.LiteralC<"internet.ip">, t.LiteralC<"internet.ipv6">, t.LiteralC<"internet.userAgent">, t.LiteralC<"internet.color">, t.LiteralC<"internet.mac">, t.LiteralC<"internet.password">, t.LiteralC<"lorem.word">, t.LiteralC<"lorem.words">, t.LiteralC<"lorem.sentence">, t.LiteralC<"lorem.slug">, t.LiteralC<"lorem.sentences">, t.LiteralC<"lorem.paragraph">, t.LiteralC<"lorem.paragraphs">, t.LiteralC<"lorem.text">, t.LiteralC<"lorem.lines">, t.LiteralC<"name.firstName">, t.LiteralC<"name.lastName">, t.LiteralC<"name.findName">, t.LiteralC<"name.jobTitle">, t.LiteralC<"name.prefix">, t.LiteralC<"name.suffix">, t.LiteralC<"name.title">, t.LiteralC<"name.jobDescriptor">, t.LiteralC<"name.jobArea">, t.LiteralC<"name.jobType">, t.LiteralC<"phone.phoneNumber">, t.LiteralC<"phone.phoneNumberFormat">, t.LiteralC<"phone.phoneFormats">, t.LiteralC<"random.number">, t.LiteralC<"random.float">, t.LiteralC<"random.arrayElement">, t.LiteralC<"random.objectElement">, t.LiteralC<"random.uuid">, t.LiteralC<"random.boolean">, t.LiteralC<"random.word">, t.LiteralC<"random.words">, t.LiteralC<"random.image">, t.LiteralC<"random.locale">, t.LiteralC<"random.alphaNumeric">, t.LiteralC<"random.hexaDecimal">, t.LiteralC<"system.fileName">, t.LiteralC<"system.commonFileName">, t.LiteralC<"system.mimeType">, t.LiteralC<"system.commonFileType">, t.LiteralC<"system.commonFileExt">, t.LiteralC<"system.fileType">, t.LiteralC<"system.fileExt">, t.LiteralC<"system.directoryPath">, t.LiteralC<"system.filePath">, t.LiteralC<"system.semver">]>;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    pattern: t.StringC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    enum: t.ArrayC<t.StringC>;
}>]>]>;
export declare const JSSTProtoArray: t.TypeC<{
    type: t.LiteralC<"array">;
}>;
export declare const JSSTArray: t.UnionC<[t.Type<JSSTList, JSSTListOutput, unknown>, t.Type<JSSTTuple, JSSTTupleOutput, unknown>]>;
export declare const JSSTTopLevel: t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>;
export declare const JSSTEmptyTopLevel: t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTConstTopLevel: t.IntersectionC<[t.TypeC<{
    const: t.UnionC<[t.NumberC, t.NumberC, t.StringC, t.BooleanC, t.NullC, t.ArrayC<t.StringC>, t.TypeC<{}>]>;
}>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTReferenceTopLevel: t.IntersectionC<[t.TypeC<{
    $ref: t.StringC;
}>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTNullTopLevel: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"null">;
}>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTBooleanTopLevel: t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"boolean">;
}>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerTopLevel: t.IntersectionC<[t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMinimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMaximum: t.NumberC;
}>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMaximum: t.NumberC;
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
    exclusiveMaximum: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTSimpleIntegerTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithMinimumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithMaximumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithBoundsTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMinimumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMinimum: t.NumberC;
    maximum: t.NumberC;
}>, t.PartialC<{
    exclusiveMaximum: t.BooleanC;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMaximumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMaximum: t.NumberC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    exclusiveMaximum: t.NumberC;
    minimum: t.NumberC;
}>, t.PartialC<{
    exclusiveMinimum: t.BooleanC;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerWithNumericExclusiveBoundsTopLevel: t.IntersectionC<[t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.PartialC<{
    multipleOf: t.NumberC;
}>]>, t.TypeC<{
    exclusiveMinimum: t.NumberC;
    exclusiveMaximum: t.NumberC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTIntegerEnumTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"integer">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTNumberTopLevel: t.IntersectionC<[t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.PartialC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
    multipleOf: t.NumberC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTSimpleNumberTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.PartialC<{
    minimum: t.NumberC;
    maximum: t.NumberC;
    multipleOf: t.NumberC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTNumberEnumTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"number">;
}>, t.TypeC<{
    enum: t.ArrayC<t.NumberC>;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTAnyOfTopLevel: t.IntersectionC<[t.Type<JSSTAnyOf, JSSTAnyOfOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTAllOfTopLevel: t.IntersectionC<[t.Type<JSSTAllOf, JSSTAllOfOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTNotTopLevel: t.IntersectionC<[t.Type<JSSTNot, JSSTNotOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTOneOfTopLevel: t.IntersectionC<[t.Type<JSSTOneOf, JSSTOneOfOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTStringTopLevel: t.IntersectionC<[t.UnionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.PartialC<{
    faker: t.UnionC<[t.LiteralC<"address.zipCode">, t.LiteralC<"address.city">, t.LiteralC<"address.cityPrefix">, t.LiteralC<"address.citySuffix">, t.LiteralC<"address.streetName">, t.LiteralC<"address.streetAddress">, t.LiteralC<"address.streetSuffix">, t.LiteralC<"address.streetPrefix">, t.LiteralC<"address.secondaryAddress">, t.LiteralC<"address.county">, t.LiteralC<"address.country">, t.LiteralC<"address.countryCode">, t.LiteralC<"address.state">, t.LiteralC<"address.stateAbbr">, t.LiteralC<"address.latitude">, t.LiteralC<"address.longitude">, t.LiteralC<"commerce.color">, t.LiteralC<"commerce.department">, t.LiteralC<"commerce.productName">, t.LiteralC<"commerce.price">, t.LiteralC<"commerce.productAdjective">, t.LiteralC<"commerce.productMaterial">, t.LiteralC<"commerce.product">, t.LiteralC<"company.suffixes">, t.LiteralC<"company.companyName">, t.LiteralC<"company.companySuffix">, t.LiteralC<"company.catchPhrase">, t.LiteralC<"company.bs">, t.LiteralC<"company.catchPhraseAdjective">, t.LiteralC<"company.catchPhraseDescriptor">, t.LiteralC<"company.catchPhraseNoun">, t.LiteralC<"company.bsAdjective">, t.LiteralC<"company.bsBuzz">, t.LiteralC<"company.bsNoun">, t.LiteralC<"database.column">, t.LiteralC<"database.type">, t.LiteralC<"database.collation">, t.LiteralC<"database.engine">, t.LiteralC<"date.past">, t.LiteralC<"date.future">, t.LiteralC<"date.between">, t.LiteralC<"date.recent">, t.LiteralC<"date.soon">, t.LiteralC<"date.month">, t.LiteralC<"date.weekday">, t.LiteralC<"finance.account">, t.LiteralC<"finance.accountName">, t.LiteralC<"finance.mask">, t.LiteralC<"finance.amount">, t.LiteralC<"finance.transactionType">, t.LiteralC<"finance.currencyCode">, t.LiteralC<"finance.currencyName">, t.LiteralC<"finance.currencySymbol">, t.LiteralC<"finance.bitcoinAddress">, t.LiteralC<"finance.ethereumAddress">, t.LiteralC<"finance.iban">, t.LiteralC<"finance.bic">, t.LiteralC<"hacker.abbreviation">, t.LiteralC<"hacker.adjective">, t.LiteralC<"hacker.noun">, t.LiteralC<"hacker.verb">, t.LiteralC<"hacker.ingverb">, t.LiteralC<"hacker.phrase">, t.LiteralC<"helpers.randomize">, t.LiteralC<"helpers.slugify">, t.LiteralC<"helpers.replaceSymbolWithNumber">, t.LiteralC<"helpers.replaceSymbols">, t.LiteralC<"helpers.shuffle">, t.LiteralC<"helpers.mustache">, t.LiteralC<"helpers.createCard">, t.LiteralC<"helpers.contextualCard">, t.LiteralC<"helpers.userCard">, t.LiteralC<"helpers.createTransaction">, t.LiteralC<"image.image">, t.LiteralC<"image.avatar">, t.LiteralC<"image.imageUrl">, t.LiteralC<"image.abstract">, t.LiteralC<"image.animals">, t.LiteralC<"image.business">, t.LiteralC<"image.cats">, t.LiteralC<"image.city">, t.LiteralC<"image.food">, t.LiteralC<"image.nightlife">, t.LiteralC<"image.fashion">, t.LiteralC<"image.people">, t.LiteralC<"image.nature">, t.LiteralC<"image.sports">, t.LiteralC<"image.technics">, t.LiteralC<"image.transport">, t.LiteralC<"image.dataUri">, t.LiteralC<"internet.avatar">, t.LiteralC<"internet.email">, t.LiteralC<"internet.exampleEmail">, t.LiteralC<"internet.userName">, t.LiteralC<"internet.protocol">, t.LiteralC<"internet.url">, t.LiteralC<"internet.domainName">, t.LiteralC<"internet.domainSuffix">, t.LiteralC<"internet.domainWord">, t.LiteralC<"internet.ip">, t.LiteralC<"internet.ipv6">, t.LiteralC<"internet.userAgent">, t.LiteralC<"internet.color">, t.LiteralC<"internet.mac">, t.LiteralC<"internet.password">, t.LiteralC<"lorem.word">, t.LiteralC<"lorem.words">, t.LiteralC<"lorem.sentence">, t.LiteralC<"lorem.slug">, t.LiteralC<"lorem.sentences">, t.LiteralC<"lorem.paragraph">, t.LiteralC<"lorem.paragraphs">, t.LiteralC<"lorem.text">, t.LiteralC<"lorem.lines">, t.LiteralC<"name.firstName">, t.LiteralC<"name.lastName">, t.LiteralC<"name.findName">, t.LiteralC<"name.jobTitle">, t.LiteralC<"name.prefix">, t.LiteralC<"name.suffix">, t.LiteralC<"name.title">, t.LiteralC<"name.jobDescriptor">, t.LiteralC<"name.jobArea">, t.LiteralC<"name.jobType">, t.LiteralC<"phone.phoneNumber">, t.LiteralC<"phone.phoneNumberFormat">, t.LiteralC<"phone.phoneFormats">, t.LiteralC<"random.number">, t.LiteralC<"random.float">, t.LiteralC<"random.arrayElement">, t.LiteralC<"random.objectElement">, t.LiteralC<"random.uuid">, t.LiteralC<"random.boolean">, t.LiteralC<"random.word">, t.LiteralC<"random.words">, t.LiteralC<"random.image">, t.LiteralC<"random.locale">, t.LiteralC<"random.alphaNumeric">, t.LiteralC<"random.hexaDecimal">, t.LiteralC<"system.fileName">, t.LiteralC<"system.commonFileName">, t.LiteralC<"system.mimeType">, t.LiteralC<"system.commonFileType">, t.LiteralC<"system.commonFileExt">, t.LiteralC<"system.fileType">, t.LiteralC<"system.fileExt">, t.LiteralC<"system.directoryPath">, t.LiteralC<"system.filePath">, t.LiteralC<"system.semver">]>;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    pattern: t.StringC;
}>]>, t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    enum: t.ArrayC<t.StringC>;
}>]>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTSimpleStringTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.PartialC<{
    faker: t.UnionC<[t.LiteralC<"address.zipCode">, t.LiteralC<"address.city">, t.LiteralC<"address.cityPrefix">, t.LiteralC<"address.citySuffix">, t.LiteralC<"address.streetName">, t.LiteralC<"address.streetAddress">, t.LiteralC<"address.streetSuffix">, t.LiteralC<"address.streetPrefix">, t.LiteralC<"address.secondaryAddress">, t.LiteralC<"address.county">, t.LiteralC<"address.country">, t.LiteralC<"address.countryCode">, t.LiteralC<"address.state">, t.LiteralC<"address.stateAbbr">, t.LiteralC<"address.latitude">, t.LiteralC<"address.longitude">, t.LiteralC<"commerce.color">, t.LiteralC<"commerce.department">, t.LiteralC<"commerce.productName">, t.LiteralC<"commerce.price">, t.LiteralC<"commerce.productAdjective">, t.LiteralC<"commerce.productMaterial">, t.LiteralC<"commerce.product">, t.LiteralC<"company.suffixes">, t.LiteralC<"company.companyName">, t.LiteralC<"company.companySuffix">, t.LiteralC<"company.catchPhrase">, t.LiteralC<"company.bs">, t.LiteralC<"company.catchPhraseAdjective">, t.LiteralC<"company.catchPhraseDescriptor">, t.LiteralC<"company.catchPhraseNoun">, t.LiteralC<"company.bsAdjective">, t.LiteralC<"company.bsBuzz">, t.LiteralC<"company.bsNoun">, t.LiteralC<"database.column">, t.LiteralC<"database.type">, t.LiteralC<"database.collation">, t.LiteralC<"database.engine">, t.LiteralC<"date.past">, t.LiteralC<"date.future">, t.LiteralC<"date.between">, t.LiteralC<"date.recent">, t.LiteralC<"date.soon">, t.LiteralC<"date.month">, t.LiteralC<"date.weekday">, t.LiteralC<"finance.account">, t.LiteralC<"finance.accountName">, t.LiteralC<"finance.mask">, t.LiteralC<"finance.amount">, t.LiteralC<"finance.transactionType">, t.LiteralC<"finance.currencyCode">, t.LiteralC<"finance.currencyName">, t.LiteralC<"finance.currencySymbol">, t.LiteralC<"finance.bitcoinAddress">, t.LiteralC<"finance.ethereumAddress">, t.LiteralC<"finance.iban">, t.LiteralC<"finance.bic">, t.LiteralC<"hacker.abbreviation">, t.LiteralC<"hacker.adjective">, t.LiteralC<"hacker.noun">, t.LiteralC<"hacker.verb">, t.LiteralC<"hacker.ingverb">, t.LiteralC<"hacker.phrase">, t.LiteralC<"helpers.randomize">, t.LiteralC<"helpers.slugify">, t.LiteralC<"helpers.replaceSymbolWithNumber">, t.LiteralC<"helpers.replaceSymbols">, t.LiteralC<"helpers.shuffle">, t.LiteralC<"helpers.mustache">, t.LiteralC<"helpers.createCard">, t.LiteralC<"helpers.contextualCard">, t.LiteralC<"helpers.userCard">, t.LiteralC<"helpers.createTransaction">, t.LiteralC<"image.image">, t.LiteralC<"image.avatar">, t.LiteralC<"image.imageUrl">, t.LiteralC<"image.abstract">, t.LiteralC<"image.animals">, t.LiteralC<"image.business">, t.LiteralC<"image.cats">, t.LiteralC<"image.city">, t.LiteralC<"image.food">, t.LiteralC<"image.nightlife">, t.LiteralC<"image.fashion">, t.LiteralC<"image.people">, t.LiteralC<"image.nature">, t.LiteralC<"image.sports">, t.LiteralC<"image.technics">, t.LiteralC<"image.transport">, t.LiteralC<"image.dataUri">, t.LiteralC<"internet.avatar">, t.LiteralC<"internet.email">, t.LiteralC<"internet.exampleEmail">, t.LiteralC<"internet.userName">, t.LiteralC<"internet.protocol">, t.LiteralC<"internet.url">, t.LiteralC<"internet.domainName">, t.LiteralC<"internet.domainSuffix">, t.LiteralC<"internet.domainWord">, t.LiteralC<"internet.ip">, t.LiteralC<"internet.ipv6">, t.LiteralC<"internet.userAgent">, t.LiteralC<"internet.color">, t.LiteralC<"internet.mac">, t.LiteralC<"internet.password">, t.LiteralC<"lorem.word">, t.LiteralC<"lorem.words">, t.LiteralC<"lorem.sentence">, t.LiteralC<"lorem.slug">, t.LiteralC<"lorem.sentences">, t.LiteralC<"lorem.paragraph">, t.LiteralC<"lorem.paragraphs">, t.LiteralC<"lorem.text">, t.LiteralC<"lorem.lines">, t.LiteralC<"name.firstName">, t.LiteralC<"name.lastName">, t.LiteralC<"name.findName">, t.LiteralC<"name.jobTitle">, t.LiteralC<"name.prefix">, t.LiteralC<"name.suffix">, t.LiteralC<"name.title">, t.LiteralC<"name.jobDescriptor">, t.LiteralC<"name.jobArea">, t.LiteralC<"name.jobType">, t.LiteralC<"phone.phoneNumber">, t.LiteralC<"phone.phoneNumberFormat">, t.LiteralC<"phone.phoneFormats">, t.LiteralC<"random.number">, t.LiteralC<"random.float">, t.LiteralC<"random.arrayElement">, t.LiteralC<"random.objectElement">, t.LiteralC<"random.uuid">, t.LiteralC<"random.boolean">, t.LiteralC<"random.word">, t.LiteralC<"random.words">, t.LiteralC<"random.image">, t.LiteralC<"random.locale">, t.LiteralC<"random.alphaNumeric">, t.LiteralC<"random.hexaDecimal">, t.LiteralC<"system.fileName">, t.LiteralC<"system.commonFileName">, t.LiteralC<"system.mimeType">, t.LiteralC<"system.commonFileType">, t.LiteralC<"system.commonFileExt">, t.LiteralC<"system.fileType">, t.LiteralC<"system.fileExt">, t.LiteralC<"system.directoryPath">, t.LiteralC<"system.filePath">, t.LiteralC<"system.semver">]>;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTRegexTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    pattern: t.StringC;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTStringEnumTopLevel: t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    type: t.LiteralC<"string">;
}>, t.TypeC<{
    enum: t.ArrayC<t.StringC>;
}>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTArrayTopLevel: t.IntersectionC<[t.UnionC<[t.Type<JSSTList, JSSTListOutput, unknown>, t.Type<JSSTTuple, JSSTTupleOutput, unknown>]>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTListTopLevel: t.IntersectionC<[t.Type<JSSTList, JSSTListOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTTupleTopLevel: t.IntersectionC<[t.Type<JSSTTuple, JSSTTupleOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSSTObjectTopLevel: t.IntersectionC<[t.Type<JSSTObject, JSSTObjectOutput, unknown>, t.PartialC<{
    $schema: t.StringC;
    $id: t.StringC;
    definitions: t.RecordC<t.StringC, t.Type<JSSTAnything, JSSTAnythingOutput, unknown>>;
}>]>;
export declare const JSONSchemaObject: t.TypeC<{}>;
export declare type JSSTList = t.TypeOf<typeof JSSTProtoArray> & {
    items: t.TypeOf<typeof JSSTAnything>;
    uniqueItems?: boolean;
    minItems?: number;
    maxItems?: number;
};
declare type JSSTListOutput = t.OutputOf<typeof JSSTProtoArray> & {
    items: t.OutputOf<typeof JSSTAnything>;
    uniqueItems?: boolean;
    minItems?: number;
    maxItems?: number;
};
export declare type JSSTAnything = t.TypeOf<typeof JSSTEmpty> | t.TypeOf<typeof JSSTConst> | t.TypeOf<typeof JSSTReference> | t.TypeOf<typeof JSSTNull> | t.TypeOf<typeof JSSTBoolean> | t.TypeOf<typeof JSSTInteger> | t.TypeOf<typeof JSSTNumber> | t.TypeOf<typeof JSSTString> | t.TypeOf<typeof JSSTArray> | t.TypeOf<typeof JSSTObject> | t.TypeOf<typeof JSSTOneOf> | t.TypeOf<typeof JSSTAnyOf> | t.TypeOf<typeof JSSTAllOf> | t.TypeOf<typeof JSSTNot>;
declare type JSSTAnythingOutput = t.OutputOf<typeof JSSTEmpty> | t.OutputOf<typeof JSSTConst> | t.OutputOf<typeof JSSTReference> | t.OutputOf<typeof JSSTNull> | t.OutputOf<typeof JSSTBoolean> | t.OutputOf<typeof JSSTInteger> | t.OutputOf<typeof JSSTNumber> | t.OutputOf<typeof JSSTString> | t.OutputOf<typeof JSSTArray> | t.OutputOf<typeof JSSTObject> | t.OutputOf<typeof JSSTOneOf> | t.OutputOf<typeof JSSTAnyOf> | t.OutputOf<typeof JSSTAllOf> | t.OutputOf<typeof JSSTNot>;
export declare type JSSTTuple = t.TypeOf<typeof JSSTProtoArray> & {
    items: Array<t.TypeOf<typeof JSSTAnything>>;
};
declare type JSSTTupleOutput = t.OutputOf<typeof JSSTProtoArray> & {
    items: Array<t.OutputOf<typeof JSSTAnything>>;
};
export interface JSSTObject {
    type: "object";
    required?: Array<string>;
    dependencies?: Record<string, Array<string>>;
    additionalProperties?: boolean | t.TypeOf<typeof JSSTAnything>;
    patternProperties?: Record<string, t.TypeOf<typeof JSSTAnything>>;
    properties?: Record<string, t.TypeOf<typeof JSSTAnything>>;
}
interface JSSTObjectOutput {
    type: "object";
    required?: Array<string>;
    dependencies?: Record<string, Array<string>>;
    additionalProperties?: boolean | t.OutputOf<typeof JSSTAnything>;
    patternProperties?: Record<string, t.OutputOf<typeof JSSTAnything>>;
    properties?: Record<string, t.OutputOf<typeof JSSTAnything>>;
}
export interface JSSTOneOf {
    oneOf: Array<t.TypeOf<typeof JSSTAnything>>;
}
interface JSSTOneOfOutput {
    oneOf: Array<t.OutputOf<typeof JSSTAnything>>;
}
export interface JSSTAnyOf {
    anyOf: Array<t.TypeOf<typeof JSSTAnything>>;
}
interface JSSTAnyOfOutput {
    anyOf: Array<t.OutputOf<typeof JSSTAnything>>;
}
export interface JSSTAllOf {
    allOf: Array<t.TypeOf<typeof JSSTAnything>>;
}
interface JSSTAllOfOutput {
    allOf: Array<t.OutputOf<typeof JSSTAnything>>;
}
export interface JSSTNot {
    not: t.TypeOf<typeof JSSTAnything>;
}
interface JSSTNotOutput {
    not: t.OutputOf<typeof JSSTAnything>;
}
export interface JSSTEmpty {
}
export interface JSSTConst {
    const: number | number | string | boolean | null | Array<string> | {};
}
export interface JSSTReference {
    $ref: string;
}
export interface JSSTNull {
    type: "null";
}
export interface JSSTBoolean {
    type: "boolean";
}
export interface JSSTProtoInteger {
    type: "integer";
}
export declare type JSSTSimpleInteger = t.TypeOf<typeof JSSTProtoInteger> & {
    multipleOf?: number;
};
export declare type JSSTIntegerWithMinimum = t.TypeOf<typeof JSSTSimpleInteger> & {
    minimum: number;
    exclusiveMinimum?: boolean;
};
export declare type JSSTIntegerWithMaximum = t.TypeOf<typeof JSSTSimpleInteger> & {
    maximum: number;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithBounds = t.TypeOf<typeof JSSTSimpleInteger> & {
    minimum: number;
    maximum: number;
    exclusiveMinimum?: boolean;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveMinimum = t.TypeOf<typeof JSSTSimpleInteger> & {
    exclusiveMinimum: number;
};
export declare type JSSTIntegerWithNumericExclusiveMinimumAndMaximum = t.TypeOf<typeof JSSTSimpleInteger> & {
    exclusiveMinimum: number;
    maximum: number;
    exclusiveMaximum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveMaximum = t.TypeOf<typeof JSSTSimpleInteger> & {
    exclusiveMaximum: number;
};
export declare type JSSTIntegerWithNumericExclusiveMaximumAndMinimum = t.TypeOf<typeof JSSTSimpleInteger> & {
    exclusiveMaximum: number;
    minimum: number;
    exclusiveMinimum?: boolean;
};
export declare type JSSTIntegerWithNumericExclusiveBounds = t.TypeOf<typeof JSSTSimpleInteger> & {
    exclusiveMinimum: number;
    exclusiveMaximum: number;
};
export declare type JSSTIntegerEnum = t.TypeOf<typeof JSSTProtoInteger> & {
    enum: Array<number>;
};
export declare type JSSTInteger = t.TypeOf<typeof JSSTSimpleInteger> | t.TypeOf<typeof JSSTIntegerWithMinimum> | t.TypeOf<typeof JSSTIntegerWithMaximum> | t.TypeOf<typeof JSSTIntegerWithBounds> | t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMinimum> | t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMinimumAndMaximum> | t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMaximum> | t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMaximumAndMinimum> | t.TypeOf<typeof JSSTIntegerWithNumericExclusiveBounds> | t.TypeOf<typeof JSSTIntegerEnum>;
export interface JSSTProtoNumber {
    type: "number";
}
export declare type JSSTSimpleNumber = t.TypeOf<typeof JSSTProtoNumber> & {
    minimum?: number;
    maximum?: number;
    multipleOf?: number;
};
export declare type JSSTNumberEnum = t.TypeOf<typeof JSSTProtoNumber> & {
    enum: Array<number>;
};
export declare type JSSTNumber = t.TypeOf<typeof JSSTSimpleNumber> | t.TypeOf<typeof JSSTNumberEnum>;
export interface JSSTProtoString {
    type: "string";
}
export declare type JSSTSimpleString = t.TypeOf<typeof JSSTProtoString> & {
    faker?: "address.zipCode" | "address.city" | "address.cityPrefix" | "address.citySuffix" | "address.streetName" | "address.streetAddress" | "address.streetSuffix" | "address.streetPrefix" | "address.secondaryAddress" | "address.county" | "address.country" | "address.countryCode" | "address.state" | "address.stateAbbr" | "address.latitude" | "address.longitude" | "commerce.color" | "commerce.department" | "commerce.productName" | "commerce.price" | "commerce.productAdjective" | "commerce.productMaterial" | "commerce.product" | "company.suffixes" | "company.companyName" | "company.companySuffix" | "company.catchPhrase" | "company.bs" | "company.catchPhraseAdjective" | "company.catchPhraseDescriptor" | "company.catchPhraseNoun" | "company.bsAdjective" | "company.bsBuzz" | "company.bsNoun" | "database.column" | "database.type" | "database.collation" | "database.engine" | "date.past" | "date.future" | "date.between" | "date.recent" | "date.soon" | "date.month" | "date.weekday" | "finance.account" | "finance.accountName" | "finance.mask" | "finance.amount" | "finance.transactionType" | "finance.currencyCode" | "finance.currencyName" | "finance.currencySymbol" | "finance.bitcoinAddress" | "finance.ethereumAddress" | "finance.iban" | "finance.bic" | "hacker.abbreviation" | "hacker.adjective" | "hacker.noun" | "hacker.verb" | "hacker.ingverb" | "hacker.phrase" | "helpers.randomize" | "helpers.slugify" | "helpers.replaceSymbolWithNumber" | "helpers.replaceSymbols" | "helpers.shuffle" | "helpers.mustache" | "helpers.createCard" | "helpers.contextualCard" | "helpers.userCard" | "helpers.createTransaction" | "image.image" | "image.avatar" | "image.imageUrl" | "image.abstract" | "image.animals" | "image.business" | "image.cats" | "image.city" | "image.food" | "image.nightlife" | "image.fashion" | "image.people" | "image.nature" | "image.sports" | "image.technics" | "image.transport" | "image.dataUri" | "internet.avatar" | "internet.email" | "internet.exampleEmail" | "internet.userName" | "internet.protocol" | "internet.url" | "internet.domainName" | "internet.domainSuffix" | "internet.domainWord" | "internet.ip" | "internet.ipv6" | "internet.userAgent" | "internet.color" | "internet.mac" | "internet.password" | "lorem.word" | "lorem.words" | "lorem.sentence" | "lorem.slug" | "lorem.sentences" | "lorem.paragraph" | "lorem.paragraphs" | "lorem.text" | "lorem.lines" | "name.firstName" | "name.lastName" | "name.findName" | "name.jobTitle" | "name.prefix" | "name.suffix" | "name.title" | "name.jobDescriptor" | "name.jobArea" | "name.jobType" | "phone.phoneNumber" | "phone.phoneNumberFormat" | "phone.phoneFormats" | "random.number" | "random.float" | "random.arrayElement" | "random.objectElement" | "random.uuid" | "random.boolean" | "random.word" | "random.words" | "random.image" | "random.locale" | "random.alphaNumeric" | "random.hexaDecimal" | "system.fileName" | "system.commonFileName" | "system.mimeType" | "system.commonFileType" | "system.commonFileExt" | "system.fileType" | "system.fileExt" | "system.directoryPath" | "system.filePath" | "system.semver";
};
export declare type JSSTRegex = t.TypeOf<typeof JSSTProtoString> & {
    pattern: string;
};
export declare type JSSTStringEnum = t.TypeOf<typeof JSSTProtoString> & {
    enum: Array<string>;
};
export declare type JSSTString = t.TypeOf<typeof JSSTSimpleString> | t.TypeOf<typeof JSSTRegex> | t.TypeOf<typeof JSSTStringEnum>;
export interface JSSTProtoArray {
    type: "array";
}
export declare type JSSTArray = t.TypeOf<typeof JSSTList> | t.TypeOf<typeof JSSTTuple>;
export interface JSSTTopLevel {
    $schema?: string;
    $id?: string;
    definitions?: Record<string, t.TypeOf<typeof JSSTAnything>>;
}
export declare type JSSTEmptyTopLevel = t.TypeOf<typeof JSSTEmpty> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTConstTopLevel = t.TypeOf<typeof JSSTConst> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTReferenceTopLevel = t.TypeOf<typeof JSSTReference> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTNullTopLevel = t.TypeOf<typeof JSSTNull> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTBooleanTopLevel = t.TypeOf<typeof JSSTBoolean> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerTopLevel = t.TypeOf<typeof JSSTInteger> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTSimpleIntegerTopLevel = t.TypeOf<typeof JSSTSimpleInteger> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithMinimumTopLevel = t.TypeOf<typeof JSSTIntegerWithMinimum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithMaximumTopLevel = t.TypeOf<typeof JSSTIntegerWithMaximum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithBoundsTopLevel = t.TypeOf<typeof JSSTIntegerWithBounds> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithNumericExclusiveMinimumTopLevel = t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMinimum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithNumericExclusiveMinimumAndMaximumTopLevel = t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMinimumAndMaximum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithNumericExclusiveMaximumTopLevel = t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMaximum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithNumericExclusiveMaximumAndMinimumTopLevel = t.TypeOf<typeof JSSTIntegerWithNumericExclusiveMaximumAndMinimum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerWithNumericExclusiveBoundsTopLevel = t.TypeOf<typeof JSSTIntegerWithNumericExclusiveBounds> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTIntegerEnumTopLevel = t.TypeOf<typeof JSSTIntegerEnum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTNumberTopLevel = t.TypeOf<typeof JSSTNumber> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTSimpleNumberTopLevel = t.TypeOf<typeof JSSTSimpleNumber> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTNumberEnumTopLevel = t.TypeOf<typeof JSSTNumberEnum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTAnyOfTopLevel = t.TypeOf<typeof JSSTAnyOf> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTAllOfTopLevel = t.TypeOf<typeof JSSTAllOf> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTNotTopLevel = t.TypeOf<typeof JSSTNot> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTOneOfTopLevel = t.TypeOf<typeof JSSTOneOf> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTStringTopLevel = t.TypeOf<typeof JSSTString> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTSimpleStringTopLevel = t.TypeOf<typeof JSSTSimpleString> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTRegexTopLevel = t.TypeOf<typeof JSSTRegex> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTStringEnumTopLevel = t.TypeOf<typeof JSSTStringEnum> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTArrayTopLevel = t.TypeOf<typeof JSSTArray> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTListTopLevel = t.TypeOf<typeof JSSTList> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTTupleTopLevel = t.TypeOf<typeof JSSTTuple> & t.TypeOf<typeof JSSTTopLevel>;
export declare type JSSTObjectTopLevel = t.TypeOf<typeof JSSTObject> & t.TypeOf<typeof JSSTTopLevel>;
export interface JSONSchemaObject {
}
export {};
//# sourceMappingURL=index2.d.ts.map