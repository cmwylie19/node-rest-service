"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const readable = require("readable-stream");
const unmock_core_1 = require("unmock-core");
const url = require("url");
class BodySerializer extends readable.Transform {
    static fromIncoming(incomingMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializer = new BodySerializer();
            yield readable.pipeline(incomingMessage, serializer);
            return serializer.body;
        });
    }
    _transform(chunk, _, done) {
        this.body = (this.body || "") + chunk.toString();
        this.push(chunk);
        done();
    }
}
function extractVars(interceptedRequest) {
    const headers = interceptedRequest.headers;
    const hostWithPort = headers.host;
    if (!hostWithPort) {
        throw new Error("No host");
    }
    const host = hostWithPort.split(":")[0];
    const { method: methodNode, url: requestUrl } = interceptedRequest;
    if (!requestUrl) {
        throw new Error("Missing request url.");
    }
    if (!methodNode) {
        throw new Error("Missing method");
    }
    const { path, pathname, query } = url.parse(requestUrl, true);
    if (!path) {
        throw new Error("Could not parse path");
    }
    if (!pathname) {
        throw new Error("Could not parse pathname");
    }
    const method = methodNode.toLowerCase();
    if (!unmock_core_1.isRESTMethod(method)) {
        throw new Error(`Unknown REST method: ${method}`);
    }
    return {
        headers,
        host,
        method,
        path,
        pathname,
        query,
    };
}
const jsonOrBust = (s) => {
    if (s === undefined) {
        return undefined;
    }
    try {
        return JSON.parse(s);
    }
    catch (_a) {
        return undefined;
    }
};
exports.serializeRequest = (interceptedRequest) => __awaiter(void 0, void 0, void 0, function* () {
    const { headers, host, method, path, pathname, query } = extractVars(interceptedRequest);
    const isEncrypted = interceptedRequest.connection.encrypted;
    const protocol = isEncrypted ? "https" : "http";
    const body = yield BodySerializer.fromIncoming(interceptedRequest);
    const bodyAsJson = jsonOrBust(body);
    const serializedRequest = Object.assign(Object.assign({ body }, (bodyAsJson !== undefined ? { bodyAsJson } : {})), { headers,
        host,
        method,
        path,
        pathname,
        protocol,
        query });
    return serializedRequest;
});
//# sourceMappingURL=index.js.map