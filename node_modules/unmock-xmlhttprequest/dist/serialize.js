"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("debug");
const unmock_core_1 = require("unmock-core");
const URLParse = require("url-parse");
const debugLog = debug_1.default("unmock:fetch-mitm");
exports.default = (url, methodInUpperOrLowercase, headers, body) => {
    const method = methodInUpperOrLowercase.toLowerCase();
    debugLog(`Serializing request to: ${method} ${url}`);
    if (!unmock_core_1.typeUtils.isRESTMethod(method)) {
        throw new Error(`Unknown method: ${method}`);
    }
    const parsedUrl = new URLParse(url, true);
    const protocolWithoutColon = parsedUrl.protocol.replace(":", "");
    if (!unmock_core_1.typeUtils.isKnownProtocol(protocolWithoutColon)) {
        throw new Error(`Unknown protocol: ${protocolWithoutColon}`);
    }
    const useableBody = typeof body === "string" ? body : undefined;
    let maybeJson;
    try {
        if (useableBody) {
            maybeJson = JSON.parse(useableBody);
        }
    }
    catch (_a) {
    }
    const path = "/" +
        url
            .replace("https://", "")
            .replace("http://", "")
            .split("/")
            .slice(1)
            .join("/");
    const req = {
        body: useableBody,
        bodyAsJson: maybeJson,
        method,
        headers: Object.entries(headers)
            .map(([a, b]) => ({ [a.toLowerCase()]: b }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}),
        host: parsedUrl.host,
        path,
        pathname: parsedUrl.pathname,
        query: parsedUrl.query,
        protocol: protocolWithoutColon,
    };
    debugLog(`Serialized request: ${JSON.stringify(req)}`);
    return req;
};
//# sourceMappingURL=serialize.js.map