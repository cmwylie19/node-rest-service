"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const serialize_1 = require("./serialize");
const XMLHttpRequestSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
const isCreateResponse = (cb) => cb.length === 1;
exports.replaceOpenAndReturnOriginal = (cb) => {
    const XMLHttpRequestOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function (method, url, async, username, password) {
        const headerz = {};
        this.setRequestHeader = function (name, value) {
            headerz[name] = value;
            return XMLHttpRequestSetRequestHeader.apply(this, [name, value]);
        };
        this.send = function (body) {
            const request = serialize_1.default(url, method, headerz, body);
            const doResponseEnd = (rez) => {
                Object.defineProperty(this, "getResponseHeader", {
                    value: (key) => rez.headers[key],
                    writable: false,
                });
                Object.defineProperty(this, "getResponseHeaders", {
                    value: () => rez.headers,
                    writable: false,
                });
                Object.defineProperty(this, "readyState", {
                    value: 4,
                    writable: false,
                });
                Object.defineProperty(this, "response", {
                    value: rez.body ? JSON.parse(rez.body) : undefined,
                    writable: false,
                });
                Object.defineProperty(this, "responseText", {
                    value: rez.body,
                    writable: false,
                });
                Object.defineProperty(this, "status", {
                    value: rez.statusCode,
                    writable: false,
                });
                Object.defineProperty(this, "statusText", {
                    value: rez.statusCode < 400 ? "OK" : "NOT OK",
                    writable: false,
                });
                Object.defineProperty(this, "responseURL", {
                    value: url,
                    writable: false,
                });
                if (this.onloadstart) {
                    this.onloadstart(new ProgressEvent("unmock-done"));
                }
                if (this.onload) {
                    this.onload(new ProgressEvent("unmock-done"));
                }
                if (this.onloadend) {
                    this.onloadend(new ProgressEvent("unmock-done"));
                }
                if (this.onreadystatechange) {
                    this.onreadystatechange(new Event("unmock-done"));
                }
            };
            if (isCreateResponse(cb)) {
                doResponseEnd(cb(request));
            }
            else {
                cb(request, doResponseEnd, (e) => {
                    if (this.onerror) {
                        this.onerror(new ProgressEvent(`${e.message} ${e.stack}`));
                    }
                });
            }
        };
        const res = XMLHttpRequestOpen.apply(this, [
            method,
            url,
            async || false,
            username,
            password,
        ]);
        return res;
    };
    return XMLHttpRequestOpen;
};
exports.default = exports.replaceOpenAndReturnOriginal;
//# sourceMappingURL=xmlhttprequest.js.map