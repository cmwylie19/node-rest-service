"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const full_1 = require("loas3/dist/generated/full");
const jsonschema = require("@meeshkanml/jsonschema");
const Array_1 = require("fp-ts/lib/Array");
const Option_1 = require("fp-ts/lib/Option");
const monocle_ts_1 = require("monocle-ts");
const APPLICATION_JSON = "application/json";
exports.objectToArray = () => new monocle_ts_1.Iso(s => Object.entries(s), a => a.reduce((q, r) => (Object.assign(Object.assign({}, q), { [r[0]]: r[1] })), {}));
exports.valueLens = () => new monocle_ts_1.Lens(s => s[1], a => s => [s[0], a]);
exports.allMethods = [
    "get",
    "post",
    "put",
    "delete",
    "options",
    "head",
    "patch",
    "trace",
];
exports.internalGetComponent = (f) => (o, i) => i ? (full_1.isReference(i) ? f(o, i.$ref.split("/")[3]) : Option_1.some(i)) : Option_1.none;
exports.getComponentFromRef = (o, d, accessor, getter) => new monocle_ts_1.Getter((a) => (a.components ? Option_1.some(a.components) : Option_1.none))
    .composeGetter(new monocle_ts_1.Getter(Option_1.fold(() => Option_1.none, a => accessor(a))))
    .composeGetter(new monocle_ts_1.Getter(Option_1.fold(() => Option_1.none, a => getter(o, a[d]))))
    .get(o);
exports.getResponseFromRef = (o, d) => exports.getComponentFromRef(o, d, a => (a.responses ? Option_1.some(a.responses) : Option_1.none), internalGetResponseFromRef);
exports.getHeaderFromRef = (o, d) => exports.getComponentFromRef(o, d, a => (a.headers ? Option_1.some(a.headers) : Option_1.none), internalGetHeaderFromRef);
exports.getParameterFromRef = (o, d) => exports.getComponentFromRef(o, d, a => (a.parameters ? Option_1.some(a.parameters) : Option_1.none), internalGetParameterFromRef);
exports.getRequestBodyFromRef = (o, d) => exports.getComponentFromRef(o, d, a => (a.requestBodies ? Option_1.some(a.requestBodies) : Option_1.none), internalGetRequestBodyFromRef);
exports.getSchemaFromRef = (o, d) => exports.getComponentFromRef(o, d, a => (a.schemas ? Option_1.some(a.schemas) : Option_1.none), internalGetSchemaFromRef);
const internalGetRequestBodyFromRef = exports.internalGetComponent(exports.getRequestBodyFromRef);
const internalGetResponseFromRef = exports.internalGetComponent(exports.getResponseFromRef);
const internalGetParameterFromRef = exports.internalGetComponent(exports.getParameterFromRef);
const internalGetSchemaFromRef = exports.internalGetComponent(exports.getSchemaFromRef);
const internalGetHeaderFromRef = exports.internalGetComponent(exports.getHeaderFromRef);
const lensToPath = (path) => monocle_ts_1.Lens.fromProp()("paths")
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof path === "boolean" ? path : path.test(i[0])))
    .composeLens(exports.valueLens());
const discernParameter = (o, name, inn) => Option_1.isNone(o)
    ? o
    : (typeof inn === "boolean" ? inn : o.value.in === inn) &&
        (typeof name === "boolean" ? name : o.value.name === name)
        ? o
        : Option_1.none;
const pathParameterInternal = (o, path, name, inn) => handleParametersInternal(o, lensToPath(path).composeOptional(monocle_ts_1.Optional.fromNullableProp()("parameters")), name, inn);
const requestBodyInternal = (o, path, operations, mediaTypes) => lensToOperations(path, operations)
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("requestBody"))
    .composePrism(new monocle_ts_1.Prism(s => full_1.isRequestBody(s)
    ? Option_1.some(s)
    : full_1.isReference(s)
        ? exports.getRequestBodyFromRef(o, s.$ref.split("/")[3])
        : Option_1.none, a => a))
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("content"))
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof mediaTypes === "boolean"
    ? mediaTypes
    : mediaTypes.indexOf(i[0]) >= 0))
    .composeLens(exports.valueLens())
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("schema"));
const methodParameterInternal = (o, path, operations, name, inn) => handleParametersInternal(o, lensToOperations(path, operations).composeOptional(monocle_ts_1.Optional.fromNullableProp()("parameters")), name, inn);
const handleParametersInternal = (o, t, name, inn) => t
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)())
    .composePrism(new monocle_ts_1.Prism(s => full_1.isParameter(s)
    ? discernParameter(Option_1.some(s), name, inn)
    : full_1.isReference(s)
        ? discernParameter(exports.getParameterFromRef(o, s.$ref.split("/")[3]), name, inn)
        : Option_1.none, a => a))
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("schema"));
const lensToOperations = (path, operations) => lensToPath(path)
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof operations === "boolean"
    ? operations
    : operations.map(z => `${z}`).indexOf(i[0]) !== -1))
    .composeLens(exports.valueLens())
    .composePrism(new monocle_ts_1.Prism(s => (full_1.isOperation(s) ? Option_1.some(s) : Option_1.none), a => a));
const lensToResponses = (path, operations) => lensToOperations(path, operations).composeLens(monocle_ts_1.Lens.fromProp()("responses"));
const minItems = (i) => (s) => (Object.assign(Object.assign({}, s), (s.type === "array" || s.items
    ? {
        minItems: typeof s.minItems === "number" && s.minItems > i ? s.minItems : i,
    }
    : {})));
const maxItems = (i) => (s) => (Object.assign(Object.assign({}, s), (s.type === "array" || s.items
    ? {
        maxItems: typeof s.maxItems === "number" && s.maxItems < i ? s.maxItems : i,
    }
    : {})));
const requiredStatus = (prop) => (s) => (Object.assign(Object.assign({}, s), (s.properties && s.properties[prop]
    ? { required: s.required ? [...new Set(s.required.concat(prop))] : [prop] }
    : {})));
const filterSchemaList = (i, key, l, keep) => l
    ? {
        [key]: l.filter((_, b) => keep ? i.indexOf(b) >= 0 : i.indexOf(b) === -1),
    }
    : {};
const changeAnyOne = (i, key, keep) => (s) => (Object.assign(Object.assign({}, s), filterSchemaList(i, key, s[key], keep)));
const itemsToList = (i, items) => new Array(i).fill(0).map(_ => items);
const listToTuple = (i) => (s) => (Object.assign(Object.assign({}, s), (s.items &&
    !(s.items instanceof Array) &&
    (!s.minItems || i >= s.minItems) &&
    (!s.maxItems || i <= s.maxItems)
    ? { items: itemsToList(i, s.items) }
    : {})));
exports.valAsConst = (val) => val === null
    ? { type: "null" }
    : typeof val === "number"
        ? { type: "number", enum: [val] }
        : typeof val === "boolean"
            ? { type: "boolean", enum: [val] }
            : typeof val === "string"
                ? { type: "string", enum: [val] }
                : val instanceof Array
                    ? { type: "array", items: val.map(i => exports.valAsConst(i)) }
                    : typeof val === "object"
                        ? {
                            type: "object",
                            properties: Object.entries(val).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: exports.valAsConst(b[1]) })), {}),
                            required: Object.keys(val),
                        }
                        : { type: "string" };
const toConstInternal = (val, definitions, s, original) => jsonschema.validate(val, Object.assign(Object.assign({}, s), { definitions })).valid
    ? exports.valAsConst(val)
    : original;
exports.changeRef = (j) => ({
    $ref: `#/definitions/${j.$ref.split("/")[3]}`,
});
exports.changeRefs = (j) => (Object.assign(Object.assign(Object.assign(Object.assign({}, j), (full_1.isReference(j.additionalProperties)
    ? { additionalProperties: exports.changeRef(j.additionalProperties) }
    : j.additionalProperties === undefined
        ? {}
        : typeof j.additionalProperties === "boolean"
            ? { additionalProperties: {} }
            : { additionalProperties: exports.changeRefs(j.additionalProperties) })), (full_1.isReference(j.items)
    ? { items: exports.changeRef(j.items) }
    : j.items === undefined
        ? {}
        : j.items instanceof Array
            ? {
                items: j.items.map(i => full_1.isReference(i) ? exports.changeRef(i) : exports.changeRefs(i)),
            }
            : { items: exports.changeRefs(j.items) })), (j.properties
    ? {
        properties: Object.entries(j.properties).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: full_1.isReference(b[1]) ? exports.changeRef(b[1]) : exports.changeRefs(b[1]) })), {}),
    }
    : {})));
const toConst = (val) => (o) => (s) => toConstInternal(val, Object.entries(o.components && o.components.schemas ? o.components.schemas : {}).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: full_1.isReference(b[1]) ? exports.changeRef(b[1]) : exports.changeRefs(b[1]) })), {}), exports.changeRefs(s), s);
const addOpenApi = (a) => (_) => a;
const drillDownSchemaProperty = (o, i) => monocle_ts_1.Optional.fromNullableProp()("properties")
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()(i))
    .composePrism(new monocle_ts_1.Prism(s => full_1.isReference(s) ? exports.getSchemaFromRef(o, s.$ref.split("/")[3]) : Option_1.some(s), a => a));
const drillDownSchemaItemOrAdditionalProperties = (i) => (o) => monocle_ts_1.Optional.fromNullableProp()(i).composePrism(new monocle_ts_1.Prism(s => full_1.isReference(s)
    ? exports.getSchemaFromRef(o, s.$ref.split("/")[3])
    : s instanceof Array
        ? Option_1.none
        : typeof s === "boolean"
            ? Option_1.some({})
            : Option_1.some(s), a => a));
const drillDownSchemaItem = drillDownSchemaItemOrAdditionalProperties("items");
const drillDownSchemaAdditionalProperties = drillDownSchemaItemOrAdditionalProperties("additionalProperties");
const drillDownSchemaItems = (o, i) => monocle_ts_1.Optional.fromNullableProp()("items")
    .composePrism(new monocle_ts_1.Prism(a => (a instanceof Array ? Option_1.some(a) : Option_1.none), a => a))
    .composeOptional(new monocle_ts_1.Optional(a => (a[i] ? Option_1.some(a[i]) : Option_1.none), a => s => [...[...s].splice(0, i), a, ...[...s].splice(i + 1)]))
    .composePrism(new monocle_ts_1.Prism(s => full_1.isReference(s) ? exports.getSchemaFromRef(o, s.$ref.split("/")[3]) : Option_1.some(s), a => a));
exports.Arr = Symbol();
exports.Addl = Symbol();
const drillDownSchemaOneLevel = (o, i) => i === exports.Arr
    ? drillDownSchemaItem(o)
    : i === exports.Addl
        ? drillDownSchemaAdditionalProperties(o)
        : typeof i === "number"
            ? drillDownSchemaItems(o, i)
            : drillDownSchemaProperty(o, i);
const lensToResponse = (o, path, operations, responses) => lensToResponses(path, operations)
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof responses === "boolean"
    ? responses
    : responses.map(z => `${z}`).indexOf(i[0]) !== -1))
    .composeLens(exports.valueLens())
    .composePrism(new monocle_ts_1.Prism(s => full_1.isResponse(s)
    ? Option_1.some(s)
    : full_1.isReference(s)
        ? exports.getResponseFromRef(o, s.$ref.split("/")[3])
        : Option_1.none, a => a));
const headerInternal = (o, path, operations, responses, name) => lensToResponse(o, path, operations, responses)
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("headers"))
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof name === "boolean" ? name : name === i[0]))
    .composeLens(exports.valueLens())
    .composePrism(new monocle_ts_1.Prism(s => full_1.isHeader(s)
    ? Option_1.some(s)
    : full_1.isReference(s)
        ? exports.getHeaderFromRef(o, s.$ref.split("/")[3])
        : Option_1.none, a => a))
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("schema"));
const responseBodyInternal = (o, path, operations, responses, mediaTypes) => lensToResponse(o, path, operations, responses)
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("content"))
    .composeIso(exports.objectToArray())
    .composeTraversal(monocle_ts_1.fromTraversable(Array_1.array)().filter(i => typeof mediaTypes === "boolean"
    ? mediaTypes
    : mediaTypes.indexOf(i[0]) >= 0))
    .composeLens(exports.valueLens())
    .composeOptional(monocle_ts_1.Optional.fromNullableProp()("schema"));
exports.responseBody = (path = true, methods = true, responses = true, mediaTypes = [APPLICATION_JSON]) => (o) => responseBodyInternal(o, coaxPath(path), coaxMethods(methods), responses, mediaTypes);
exports.header = (path = true, methods = true, responses = true, name) => (o) => headerInternal(o, coaxPath(path), coaxMethods(methods), responses, name);
exports.pathParameter = (path, name, inn) => (o) => pathParameterInternal(o, coaxPath(path), name, inn);
exports.methodParameter = (path, operations, name, inn) => (o) => methodParameterInternal(o, coaxPath(path), coaxMethods(operations), name, inn);
exports.requestBody = (path = true, operations = true, mediaTypes = true) => (o) => requestBodyInternal(o, coaxPath(path), coaxMethods(operations), mediaTypes);
exports.changeSingleSchema = (s2s) => (traversal, path) => (o) => traversal(o)
    .composePrism(new monocle_ts_1.Prism(s => full_1.isReference(s) ? exports.getSchemaFromRef(o, s.$ref.split("/")[3]) : Option_1.some(s), a => a))
    .modify(path.reduceRight((cur, mxt) => drillDownSchemaOneLevel(o, mxt).modify(cur), s2s(o)))(o);
const cEnum = (a, keep) => (s) => (Object.assign(Object.assign({}, s), (s.enum
    ? {
        enum: s.enum.filter(i => keep ? a.indexOf(i) >= 0 : a.indexOf(i) === -1),
    }
    : {})));
exports.changeMinItems = (i) => exports.changeSingleSchema(addOpenApi(minItems(i)));
exports.changeMaxItems = (i) => exports.changeSingleSchema(addOpenApi(maxItems(i)));
exports.changeEnum = (a, keep) => exports.changeSingleSchema(addOpenApi(cEnum(a, keep)));
exports.changeRequiredStatus = (s) => exports.changeSingleSchema(addOpenApi(requiredStatus(s)));
exports.changeToConst = (v) => exports.changeSingleSchema(toConst(v));
const codesInternal = (o, path, operations, responsesMap) => lensToResponses(path, operations).modify(responsesMap)(o);
exports.changeListToTuple = (i) => exports.changeSingleSchema(addOpenApi(listToTuple(i)));
exports.anyOfKeep = (i) => exports.changeSingleSchema(addOpenApi(changeAnyOne(i, "anyOf", true)));
exports.anyOfReject = (i) => exports.changeSingleSchema(addOpenApi(changeAnyOne(i, "anyOf", false)));
exports.oneOfKeep = (i) => exports.changeSingleSchema(addOpenApi(changeAnyOne(i, "oneOf", true)));
exports.oneOfReject = (i) => exports.changeSingleSchema(addOpenApi(changeAnyOne(i, "oneOf", false)));
const coaxPath = (path) => typeof path === "string" ? new RegExp(`^${path}$`) : path;
const coaxMethods = (methods) => typeof methods === "boolean" || methods instanceof Array
    ? methods
    : [methods];
const includeCodesInternal = (o, path, operations, r) => codesInternal(o, path, operations, typeof r === "boolean"
    ? z => (r ? z : {})
    : z => r
        .filter(i => i in z)
        .map(i => ({ [i]: z[i] }))
        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
exports.includeCodes = (path = true, operations = true, r = true) => (o) => includeCodesInternal(o, coaxPath(path), coaxMethods(operations), r);
const removeCode = (r, c) => {
    const out = Object.assign({}, r);
    delete out[c];
    return out;
};
const removeCodesInternal = (o, path, operations, r) => codesInternal(o, path, operations, typeof r === "boolean" ? z => (r ? {} : z) : z => r.reduce(removeCode, z));
exports.removeCodes = (path = true, operations = true, r = true) => (o) => removeCodesInternal(o, coaxPath(path), coaxMethods(operations), r);
const mapDefaultToCodesFunction = (b) => (r) => Object.entries(r)
    .concat(r.default ? b.map(i => [i, r.default]) : [])
    .reduce((a, z) => (Object.assign(Object.assign({}, a), { [z[0]]: z[1] })), {});
const mapDefaultToCodesInternal = (o, path, operations, r) => codesInternal(o, path, operations, mapDefaultToCodesFunction(r));
exports.mapDefaultToCodes = (path = true, operations = true, r = []) => (o) => mapDefaultToCodesInternal(o, coaxPath(path), coaxMethods(operations), r);
//# sourceMappingURL=index.js.map