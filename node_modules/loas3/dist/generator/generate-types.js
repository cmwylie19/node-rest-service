"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var t = __importStar(require("io-ts-codegen"));
var full_1 = __importDefault(require("../schema/full"));
var lazy_1 = __importDefault(require("../schema/lazy"));
var fs_1 = __importDefault(require("fs"));
var prettier_1 = __importDefault(require("prettier"));
var mkdirp_1 = __importDefault(require("mkdirp"));
var path_1 = __importDefault(require("path"));
var unswitch = function (o) {
    return o === null
        ? null
        : o instanceof Array
            ? o.map(function (a) { return unswitch(a); })
            : typeof o === "object"
                ? Object.entries(o)
                    .map(function (_a) {
                    var _b;
                    var _c = __read(_a, 2), a = _c[0], b = _c[1];
                    return a === "switch"
                        ? {
                            anyOf: b
                                .filter(function (i) { return i.then !== undefined; })
                                .map(function (i) { return unswitch(i.then); })
                        }
                        : (_b = {}, _b[a] = unswitch(b), _b);
                })
                    .reduce(function (a, b) { return (__assign({}, a, b)); }, {})
                : o;
};
var HTTP_METHODS = [
    "get",
    "put",
    "post",
    "delete",
    "options",
    "head",
    "patch",
    "trace"
];
var HTTP_METHODS_REGEX = "^(" + HTTP_METHODS.join("|") + ")$";
var PathItemHack = function (objName) { return function (o) {
    var _a;
    var pi = o.definitions[objName];
    var opRef = pi.patternProperties[HTTP_METHODS_REGEX];
    var methods = HTTP_METHODS.reduce(function (a, method) {
        var _a;
        return (__assign({}, a, (_a = {}, _a[method] = opRef, _a)));
    }, {});
    return __assign({}, o, { definitions: __assign({}, o.definitions, (_a = {}, _a[objName] = __assign({}, pi, { properties: __assign({}, pi.properties, methods) }), _a)) });
}; };
var ResponsesHack = function (objName) { return function (o) {
    var _a;
    var pi = o.definitions[objName];
    var respRef = pi.patternProperties["^[1-5](?:\\d{2}|XX)$"];
    var responses = __spread(Array(500).keys()).reduce(function (a, code) {
        var _a;
        return (__assign({}, a, (_a = {}, _a[code + 100] = respRef, _a)));
    }, {
        default: respRef
    });
    return __assign({}, o, { definitions: __assign({}, o.definitions, (_a = {}, _a[objName] = __assign({}, pi, { properties: __assign({}, pi.properties, responses) }), _a)) });
}; };
var HTTPSecuritySchemeHack = function (objName) { return function (o) {
    var _a;
    return (__assign({}, o, { definitions: __assign({}, o.definitions, (_a = {}, _a[objName] = __assign({}, Object.entries(o.definitions[objName])
            .filter(function (_a) {
            var _b = __read(_a, 1), a = _b[0];
            return a !== "switch";
        })
            .reduce(function (a, _a) {
            var _b;
            var _c = __read(_a, 2), b = _c[0], c = _c[1];
            return (__assign({}, a, (_b = {}, _b[b] = c, _b)));
        }, {})), _a)) }));
}; };
function getRequiredProperties(schema) {
    var required = {};
    if (schema.required) {
        schema.required.forEach(function (k) {
            required[k] = true;
        });
    }
    return required;
}
function toInterfaceCombinator(schema) {
    var required = getRequiredProperties(schema);
    // const acceptsX = schema.patternProperties && schema.patternProperties["^x-"] !== undefined;
    var out = t.interfaceCombinator(Object.keys(schema.properties).map(function (key) {
        return t.property(key, to(schema.properties[key]), !required.hasOwnProperty(key));
    }));
    return out;
}
var isBoolean = function (u) {
    return u && typeof u === "object" && u.type === "boolean";
};
var isNumber = function (u) {
    return u && typeof u === "object" && u.type === "number";
};
var isInteger = function (u) {
    return u && typeof u === "object" && u.type === "integer";
};
var isNull = function (u) {
    return u && typeof u === "object" && u.type === "null";
};
var isArray = function (u) {
    return u && typeof u === "object" && u.type === "array";
};
var isRecord = function (u) {
    return u &&
        typeof u === "object" &&
        u.properties === undefined &&
        typeof u.additionalProperties === "object";
};
var isEmpty = function (u) {
    return u && typeof u === "object" && Object.keys(u).length === 0;
};
var isPatternedRecord = function (u) {
    return u &&
        typeof u === "object" &&
        u.properties === undefined &&
        typeof u.patternProperties === "object";
};
var isObject = function (u) {
    return u &&
        typeof u === "object" &&
        u.type === "object" &&
        u.properties !== undefined;
};
var isRef = function (u) {
    return u && typeof u === "object" && u.$ref !== undefined;
};
var isAnyOf = function (u) {
    return u && typeof u === "object" && u.anyOf !== undefined;
};
var makeTypeGuard = function (a, b) {
    var typeGuard = isObject(b) &&
        b.patternProperties &&
        b.patternProperties["^x-"] !== undefined
        ? " && new Set([..." + JSON.stringify(Object.keys(b.properties)) + ", ...Object.keys(u).filter(i => i.slice(0, 2) !== \"x-\")]).size === " + Object.keys(b.properties).length
        : "";
    return "export const is" + a + " = (u: unknown): u is " + a + " => " + a + ".is(u)" + typeGuard + ";";
};
var to = function (schema) {
    return isRef(schema)
        ? t.identifier(schema.$ref.split("/").slice(-1)[0])
        : isAnyOf(schema)
            ? t.unionCombinator(schema.anyOf.map(function (i) { return to(i); }))
            : isRecord(schema)
                ? t.recordCombinator(t.stringType, to(schema.additionalProperties))
                : isObject(schema)
                    ? toInterfaceCombinator(schema)
                    : isPatternedRecord(schema)
                        ? t.recordCombinator(t.stringType, to(Object.entries(schema.patternProperties).filter(function (_a) {
                            var _b = __read(_a, 1), a = _b[0];
                            return a !== "^x-";
                        })[0][1]))
                        : isArray(schema)
                            ? t.arrayCombinator(schema.items
                                ? to(schema.items)
                                : t.arrayCombinator(t.identifier("L04$3")))
                            : isNumber(schema)
                                ? t.numberType
                                : isInteger(schema)
                                    ? t.numberType // t.intType - because this causes weirdness in the types, we let go
                                    : isNull(schema)
                                        ? t.nullType
                                        : isBoolean(schema)
                                            ? t.booleanType
                                            : isEmpty(schema)
                                                ? t.arrayCombinator(t.identifier("L04$3"))
                                                : t.stringType;
}; // no need for string schema
/**
 * Validates a schema by adding quotation marks next to number keys,
 * and replaces internal empty array with `any` or `t.any`.
 * Example: `500: { }` ==> `"500": { }`
 * @param s schema
 */
var numberHack = function (s) {
    return s
        .replace(/([1-5]\d\d)(\??):/g, '"$1"$2:')
        .replace(/t.array\(L04\$3\)/g, "t.any")
        .replace(/Array\<L04\$3\>/g, "any");
};
var generateTypes = function (_a) {
    var input = _a.input, output = _a.output, toplevel = _a.toplevel, responsesName = _a.responsesName, pathItemName = _a.pathItemName, httpSecuritySchemaName = _a.httpSecuritySchemaName;
    mkdirp_1.default.sync(path_1.default.dirname(output));
    var full = unswitch(HTTPSecuritySchemeHack(httpSecuritySchemaName)(ResponsesHack(responsesName)(PathItemHack(pathItemName)(input))));
    var definitions = full.definitions, fullObj = __rest(full, ["definitions"]);
    var declarations = Object.entries(definitions)
        .map(function (_a) {
        var _b = __read(_a, 2), a = _b[0], b = _b[1];
        return t.typeDeclaration(a, to(b));
    })
        .concat(t.typeDeclaration(toplevel, to(fullObj)));
    var sorted = t.sort(declarations);
    var typeGuards = Object.entries(definitions).map(function (_a) {
        var _b = __read(_a, 2), a = _b[0], b = _b[1];
        return makeTypeGuard(a, b);
    });
    typeGuards.push(makeTypeGuard(toplevel, fullObj));
    fs_1.default.writeFileSync(output, numberHack(prettier_1.default.format([
        "import * as t from \"io-ts\";\n"
    ]
        .concat(sorted.map(function (d) { return t.printRuntime(d); }))
        .concat(sorted.map(function (d) { return "export " + t.printStatic(d); }))
        .concat(typeGuards)
        .join("\n"), {
        parser: "typescript"
    })));
};
generateTypes({
    input: full_1.default,
    output: "./src/generated/full.ts",
    toplevel: "OpenAPIObject",
    responsesName: "Responses",
    pathItemName: "PathItem",
    httpSecuritySchemaName: "HTTPSecurityScheme"
});
generateTypes({
    input: lazy_1.default,
    output: "./src/generated/lazy.ts",
    toplevel: "$OpenAPIObject",
    responsesName: "$$Responses",
    pathItemName: "$$PathItem",
    httpSecuritySchemaName: "$HTTPSecurityScheme"
});
//# sourceMappingURL=generate-types.js.map