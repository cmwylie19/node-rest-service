/**
 * @since 2.2.3
 */
import { Invariant2 } from 'fp-ts/lib/Invariant';
import * as D from './Decoder';
import * as E from './Encoder';
import { Literal } from './Schemable';
/**
 * Laws:
 *
 * 1. `pipe(codec.decode(u), E.fold(() => u, codec.encode)) = u` for all `u` in `unknown`
 * 2. `codec.decode(codec.encode(a)) = E.right(a)` for all `a` in `A`
 *
 * @since 2.2.3
 */
export interface Codec<O, A> extends D.Decoder<A>, E.Encoder<O, A> {
}
/**
 * @since 2.2.3
 */
export declare type TypeOf<C> = E.TypeOf<C>;
/**
 * @since 2.2.3
 */
export declare type OutputOf<C> = E.OutputOf<C>;
/**
 * @since 2.2.3
 */
export declare function make<O, A>(decoder: D.Decoder<A>, encoder: E.Encoder<O, A>): Codec<O, A>;
/**
 * @since 2.2.3
 */
export declare function fromDecoder<A>(decoder: D.Decoder<A>): Codec<A, A>;
/**
 * @since 2.2.3
 */
export declare function literal<A extends ReadonlyArray<Literal>>(...values: A): Codec<A[number], A[number]>;
/**
 * @since 2.2.3
 */
export declare const string: Codec<string, string>;
/**
 * @since 2.2.3
 */
export declare const number: Codec<number, number>;
/**
 * @since 2.2.3
 */
export declare const boolean: Codec<boolean, boolean>;
/**
 * @since 2.2.3
 */
export declare const UnknownArray: Codec<Array<unknown>, Array<unknown>>;
/**
 * @since 2.2.3
 */
export declare const UnknownRecord: Codec<Record<string, unknown>, Record<string, unknown>>;
/**
 * @since 2.2.3
 */
export declare function withExpected<O, A>(codec: Codec<O, A>, expected: (actual: unknown, e: D.DecodeError) => D.DecodeError): Codec<O, A>;
/**
 * @since 2.2.3
 */
export declare function refinement<O, A, B extends A>(from: Codec<O, A>, refinement: (a: A) => a is B, expected: string): Codec<O, B>;
/**
 * @since 2.2.3
 */
export declare function nullable<O, A>(or: Codec<O, A>): Codec<null | O, null | A>;
/**
 * @since 2.2.3
 */
export declare function type<P extends Record<string, Codec<any, any>>>(properties: P): Codec<{
    [K in keyof P]: OutputOf<P[K]>;
}, {
    [K in keyof P]: TypeOf<P[K]>;
}>;
/**
 * @since 2.2.3
 */
export declare function partial<P extends Record<string, Codec<any, any>>>(properties: P): Codec<Partial<{
    [K in keyof P]: OutputOf<P[K]>;
}>, Partial<{
    [K in keyof P]: TypeOf<P[K]>;
}>>;
/**
 * @since 2.2.3
 */
export declare function record<O, A>(codomain: Codec<O, A>): Codec<Record<string, O>, Record<string, A>>;
/**
 * @since 2.2.3
 */
export declare function array<O, A>(items: Codec<O, A>): Codec<Array<O>, Array<A>>;
/**
 * @since 2.2.3
 */
export declare function tuple<C extends ReadonlyArray<Codec<any, any>>>(...components: C): Codec<{
    [K in keyof C]: OutputOf<C[K]>;
}, {
    [K in keyof C]: TypeOf<C[K]>;
}>;
/**
 * @since 2.2.3
 */
export declare function intersection<O, A, P, B>(left: Codec<O, A>, right: Codec<P, B>): Codec<O & P, A & B>;
/**
 * @since 2.2.3
 */
export declare function sum<T extends string>(tag: T): <M extends Record<string, Codec<any, any>>>(members: M) => Codec<OutputOf<M[keyof M]>, TypeOf<M[keyof M]>>;
/**
 * @since 2.2.3
 */
export declare function lazy<O, A>(id: string, f: () => Codec<O, A>): Codec<O, A>;
/**
 * @since 2.2.3
 */
export declare const imap: <E, A, B>(f: (a: A) => B, g: (b: B) => A) => (fa: Codec<E, A>) => Codec<E, B>;
/**
 * @since 2.2.3
 */
export declare const URI = "io-ts/Codec";
/**
 * @since 2.2.3
 */
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        readonly [URI]: Codec<E, A>;
    }
}
/**
 * @since 2.2.3
 */
export declare const invariantCodec: Invariant2<URI>;
