/**
 * @since 2.2.3
 */
import { Contravariant2 } from 'fp-ts/lib/Contravariant';
import { Category2 } from 'fp-ts/lib/Category';
/**
 * @since 2.2.3
 */
export interface Encoder<O, A> {
    readonly encode: (a: A) => O;
}
/**
 * @since 2.2.3
 */
export declare type TypeOf<E> = E extends Encoder<any, infer A> ? A : never;
/**
 * @since 2.2.3
 */
export declare type OutputOf<E> = E extends Encoder<infer O, any> ? O : never;
/**
 * @since 2.2.3
 */
export declare function id<A>(): Encoder<A, A>;
/**
 * @since 2.2.3
 */
export declare function nullable<O, A>(or: Encoder<O, A>): Encoder<null | O, null | A>;
/**
 * @since 2.2.3
 */
export declare function type<P extends Record<string, Encoder<any, any>>>(properties: P): Encoder<{
    [K in keyof P]: OutputOf<P[K]>;
}, {
    [K in keyof P]: TypeOf<P[K]>;
}>;
/**
 * @since 2.2.3
 */
export declare function partial<P extends Record<string, Encoder<any, any>>>(properties: P): Encoder<Partial<{
    [K in keyof P]: OutputOf<P[K]>;
}>, Partial<{
    [K in keyof P]: TypeOf<P[K]>;
}>>;
/**
 * @since 2.2.3
 */
export declare function record<O, A>(codomain: Encoder<O, A>): Encoder<Record<string, O>, Record<string, A>>;
/**
 * @since 2.2.3
 */
export declare function array<O, A>(items: Encoder<O, A>): Encoder<Array<O>, Array<A>>;
/**
 * @since 2.2.3
 */
export declare function tuple<C extends ReadonlyArray<Encoder<any, any>>>(...components: C): Encoder<{
    [K in keyof C]: OutputOf<C[K]>;
}, {
    [K in keyof C]: TypeOf<C[K]>;
}>;
/**
 * @since 2.2.3
 */
export declare function intersection<O, A, P, B>(left: Encoder<O, A>, right: Encoder<P, B>): Encoder<O & P, A & B>;
/**
 * @since 2.2.3
 */
export declare function sum<T extends string>(tag: T): <M extends Record<string, Encoder<any, any>>>(members: M) => Encoder<OutputOf<M[keyof M]>, TypeOf<M[keyof M]>>;
/**
 * @since 2.2.3
 */
export declare function lazy<O, A>(f: () => Encoder<O, A>): Encoder<O, A>;
/**
 * @since 2.2.3
 */
export declare const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Encoder<E, A>) => Encoder<E, B>;
/**
 * @since 2.2.3
 */
export declare const compose: <E, A>(ea: Encoder<E, A>) => <B>(ab: Encoder<A, B>) => Encoder<E, B>;
/**
 * @since 2.2.3
 */
export declare const URI = "io-ts/Encoder";
/**
 * @since 2.2.3
 */
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        readonly [URI]: Encoder<E, A>;
    }
}
/**
 * @since 2.2.3
 */
export declare const contravariantEncoder: Contravariant2<URI>;
/**
 * @since 2.2.3
 */
export declare const categoryEncoder: Category2<URI>;
