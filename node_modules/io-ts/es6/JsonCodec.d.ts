/**
 * @since 2.2.3
 */
import { Invariant1 } from 'fp-ts/es6/Invariant';
import * as D from './Decoder';
import * as JE from './JsonEncoder';
import * as C from './Codec';
import { Literal, Schemable1, WithRefinement1 } from './Schemable';
/**
 * Laws:
 *
 * 1. `pipe(codec.decode(u), E.fold(() => u, codec.encode)) = u` for all `u` in `unknown`
 * 2. `codec.decode(codec.encode(a)) = E.right(a)` for all `a` in `A`
 *
 * @since 2.2.3
 */
export interface JsonCodec<A> extends C.Codec<JE.Json, A> {
}
/**
 * @since 2.2.2
 */
export declare type TypeOf<C> = JE.TypeOf<C>;
/**
 * @since 2.2.3
 */
export declare const make: <A>(decoder: D.Decoder<A>, encoder: JE.JsonEncoder<A>) => JsonCodec<A>;
/**
 * @since 2.2.3
 */
export declare const literal: <A extends ReadonlyArray<Literal>>(...values: A) => JsonCodec<A[number]>;
/**
 * @since 2.2.3
 */
export declare const string: JsonCodec<string>;
/**
 * @since 2.2.3
 */
export declare const number: JsonCodec<number>;
/**
 * @since 2.2.3
 */
export declare const boolean: JsonCodec<boolean>;
/**
 * @since 2.2.3
 */
export declare const withExpected: <A>(codec: JsonCodec<A>, expected: (actual: unknown, e: D.DecodeError) => D.DecodeError) => JsonCodec<A>;
/**
 * @since 2.2.3
 */
export declare const refinement: <A, B extends A>(from: JsonCodec<A>, refinement: (a: A) => a is B, expected: string) => JsonCodec<B>;
/**
 * @since 2.2.3
 */
export declare const nullable: <A>(or: JsonCodec<A>) => JsonCodec<null | A>;
/**
 * @since 2.2.3
 */
export declare const type: <A>(properties: {
    [K in keyof A]: JsonCodec<A[K]>;
}) => JsonCodec<A>;
/**
 * @since 2.2.3
 */
export declare const partial: <A>(properties: {
    [K in keyof A]: JsonCodec<A[K]>;
}) => JsonCodec<Partial<A>>;
/**
 * @since 2.2.3
 */
export declare const record: <A>(codomain: JsonCodec<A>) => JsonCodec<Record<string, A>>;
/**
 * @since 2.2.3
 */
export declare const array: <A>(items: JsonCodec<A>) => JsonCodec<Array<A>>;
/**
 * @since 2.2.3
 */
export declare const tuple: <A extends ReadonlyArray<unknown>>(...components: {
    [K in keyof A]: JsonCodec<A[K]>;
}) => JsonCodec<A>;
/**
 * @since 2.2.3
 */
export declare const intersection: <A, B>(left: JsonCodec<A>, right: JsonCodec<B>) => JsonCodec<A & B>;
/**
 * @since 2.2.3
 */
export declare const sum: <T extends string>(tag: T) => <A>(members: {
    [K in keyof A]: JsonCodec<A[K]>;
}) => JsonCodec<A[keyof A]>;
/**
 * @since 2.2.3
 */
export declare const lazy: <A>(id: string, f: () => JsonCodec<A>) => JsonCodec<A>;
/**
 * @since 2.2.3
 */
export declare const imap: <A, B>(f: (a: A) => B, g: (b: B) => A) => (fa: JsonCodec<A>) => JsonCodec<B>;
/**
 * @since 2.2.3
 */
export declare const URI = "io-ts/JsonCodec";
/**
 * @since 2.2.3
 */
export declare type URI = typeof URI;
declare module 'fp-ts/es6/HKT' {
    interface URItoKind<A> {
        readonly [URI]: JsonCodec<A>;
    }
}
/**
 * @since 2.2.3
 */
export declare const invariantJsonCodec: Invariant1<URI>;
/**
 * @since 2.2.3
 */
export declare const schemableJsonCodec: Schemable1<URI> & WithRefinement1<URI>;
