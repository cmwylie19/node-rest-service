"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("debug");
const unmock_core_1 = require("unmock-core");
const URLParse = require("url-parse");
const types_1 = require("./types");
const debugLog = debug_1.default("unmock:fetch-mitm");
const isRequest = (url) => {
    return typeof url !== "string";
};
const parseHeadersObject = (headers) => {
    const heads = {};
    headers.forEach((value, key) => {
        heads[unmock_core_1.typeUtils.normalizeHeaderKey(key)] = value;
    });
    return heads;
};
const normalizeHeaders = (headers) => {
    const newHeaders = {};
    Object.keys(headers).forEach((key) => {
        const normalizedKey = unmock_core_1.typeUtils.normalizeHeaderKey(key);
        newHeaders[normalizedKey] = headers[key];
    });
    return newHeaders;
};
exports.parseHeaders = (urlOrRequest, init) => {
    if (isRequest(urlOrRequest)) {
        return parseHeadersObject(urlOrRequest.headers);
    }
    else if (typeof init !== "undefined") {
        const headers = init.headers;
        if (typeof headers === "undefined") {
            return {};
        }
        if (headers instanceof types_1.Headers) {
            return parseHeadersObject(headers);
        }
        if (Array.isArray(headers)) {
            const heads = {};
            headers.forEach((arr) => {
                if (arr.length < 2) {
                    throw new Error(`Too short list as header, length: {arr.length}`);
                }
                const key = unmock_core_1.typeUtils.normalizeHeaderKey(arr[0]);
                const values = arr.slice(1);
                heads[key] = values;
            });
            return heads;
        }
        return normalizeHeaders(headers);
    }
    return {};
};
const serializeFromUrlAndInit = (url, init) => {
    debugLog(`Serializing request to: ${url}`);
    const method = (init && init.method && init.method.toLowerCase()) || "get";
    if (!unmock_core_1.typeUtils.isRESTMethod(method)) {
        throw new Error(`Unknown method: ${method}`);
    }
    const parsedUrl = new URLParse(url, true);
    const protocolWithoutColon = parsedUrl.protocol.replace(":", "");
    if (!unmock_core_1.typeUtils.isKnownProtocol(protocolWithoutColon)) {
        throw new Error(`Unknown protocol: ${protocolWithoutColon}`);
    }
    const headers = exports.parseHeaders(url, init);
    const req = {
        body: undefined,
        bodyAsJson: undefined,
        method,
        headers,
        host: parsedUrl.host,
        path: parsedUrl.pathname,
        pathname: parsedUrl.pathname,
        query: parsedUrl.query,
        protocol: protocolWithoutColon,
    };
    debugLog(`Serialized request: ${JSON.stringify(req)}`);
    return req;
};
exports.default = (urlOrRequest, init) => {
    if (isRequest(urlOrRequest)) {
        throw new Error(`Request instance not yet serializable`);
    }
    return serializeFromUrlAndInit(urlOrRequest, init);
};
//# sourceMappingURL=serialize.js.map