"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const url = require("whatwg-url");
const nock_1 = require("../nock");
const service_1 = require("./service");
const serviceCore_1 = require("./serviceCore");
exports.addFromNock = (serviceStore) => (baseUrl, nameOrHeaders, name) => {
    const internalName = typeof nameOrHeaders === "string"
        ? nameOrHeaders
        : typeof name === "string"
            ? name
            : undefined;
    const requestHeaders = typeof nameOrHeaders === "object" && nameOrHeaders.reqheaders
        ? Object.entries(nameOrHeaders.reqheaders).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: nock_1.vanillaJSONSchemify(b[1]) })), {})
        : {};
    return nock_1.nockify({
        serviceStore,
        baseUrl,
        requestHeaders,
        name: internalName,
    });
};
class ServiceStore {
    constructor(coreServices) {
        const { services } = ServiceStore.extractCoresAndServices(coreServices);
        this.services = services;
    }
    static extractCoresAndServices(coreServices) {
        const services = coreServices.reduce((o, core) => (Object.assign(Object.assign({}, o), { [core.name]: new service_1.Service(core) })), {});
        return { services };
    }
    get cores() {
        return lodash_1.mapValues(this.services, (service) => service.core);
    }
    update(coreServices) {
        const { services } = ServiceStore.extractCoresAndServices(coreServices);
        this.services = services;
    }
    add(service) {
        const serviceName = service.core.name;
        if (this.serviceExists(serviceName)) {
            throw Error(`Service with name ${serviceName} exists.`);
        }
        this.updateOrAddService(service);
    }
    updateOrAddService(service) {
        const serviceName = service.core.name;
        this.services[serviceName] = service;
    }
    mock(baseUrl, nameOrHeaders, name) {
        const internalName = typeof nameOrHeaders === "string"
            ? nameOrHeaders
            : typeof name === "string"
                ? name
                : undefined;
        const requestHeaders = typeof nameOrHeaders === "object" && nameOrHeaders.reqheaders
            ? Object.entries(nameOrHeaders.reqheaders).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: nock_1.vanillaJSONSchemify(b[1]) })), {})
            : {};
        return nock_1.nockify({
            serviceStore: this,
            baseUrl,
            requestHeaders,
            name: internalName,
        });
    }
    updateOrAdd(input) {
        const hostName = new url.URL(input.baseUrl).hostname || input.baseUrl;
        const serviceName = input.name || hostName || input.baseUrl;
        const cores = this.cores;
        const baseSchema = serviceName !== undefined && cores[serviceName] !== undefined
            ? cores[serviceName].schema
            : cores[hostName] !== undefined
                ? cores[hostName].schema
                : {
                    openapi: "3.0.0",
                    info: {
                        title: "Internally built by unmock",
                        version: "0.0.0",
                    },
                    paths: {},
                };
        const newServiceCore = serviceCore_1.ServiceCore.from(baseSchema, Object.assign(Object.assign({}, input), { name: serviceName }));
        if (cores[hostName] !== undefined && cores[serviceName] === undefined) {
            delete this.services[hostName];
        }
        this.services[serviceName] = new service_1.Service(newServiceCore);
        return this;
    }
    removeAll() {
        this.update([]);
    }
    resetServices() {
        Object.values(this.services).forEach(service => service.reset());
    }
    serviceExists(name) {
        return Object.keys(this.services).includes(name);
    }
}
exports.ServiceStore = ServiceStore;
//# sourceMappingURL=serviceStore.js.map