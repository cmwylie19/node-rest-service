"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const spy_1 = require("./spy");
class ServiceCore {
    constructor(opts) {
        this.hasPaths = false;
        this.transformer = (_, o) => o;
        this.oasSchema = opts.schema;
        this.name = opts.name;
        this.hasPaths =
            this.schema !== undefined &&
                this.schema.paths !== undefined &&
                Object.keys(this.schema.paths).length > 0;
        this.callTracker = spy_1.createCallTracker();
    }
    static from(baseSchema, { baseUrl, method, query, requestHeaders, responseHeaders, body, endpoint, statusCode, response, name, }) {
        const mediaType = typeof response === "string" ||
            (response !== undefined && response.type === "string")
            ? "text/*"
            : "application/json";
        const endpointParameters = {
            parameters: [
                ...(Array.isArray(endpoint)
                    ? endpoint.filter(e => typeof e !== "string").map(e => (Object.assign({ in: "path", required: true }, (e instanceof RegExp
                        ? {
                            name: Math.random()
                                .toString(36)
                                .substring(2),
                            schema: { pattern: e.source },
                        }
                        : {
                            name: e[0],
                            schema: {
                                pattern: e[1].source,
                            },
                        }))))
                    : []),
                ...Object.entries(requestHeaders || {}).map(([n, s]) => ({
                    in: "header",
                    required: true,
                    name: n,
                    schema: s,
                })),
                ...Object.entries(query || {}).map(([n, s]) => ({
                    in: "query",
                    required: true,
                    name: n,
                    schema: s,
                })),
            ],
        };
        const newEndpoint = Array.isArray(endpoint)
            ? endpoint
                .map(e => typeof e === "string"
                ? e
                : `{${endpointParameters.parameters
                    .filter(a => Array.isArray(e)
                    ? a.name === e[0] && a.schema.pattern === e[1].source
                    : a.schema.pattern === e.source)
                    .map(a => a.name)
                    .shift()}}`)
                .join("/")
            : endpoint;
        const finalEndpoint = newEndpoint === undefined || newEndpoint.startsWith("/")
            ? newEndpoint
            : `/${newEndpoint}`;
        const newPath = finalEndpoint !== undefined &&
            method !== undefined &&
            statusCode !== undefined
            ? {
                [finalEndpoint]: Object.assign(Object.assign({}, endpointParameters), { [method]: Object.assign(Object.assign({}, (body
                        ? {
                            requestBody: {
                                content: { "application/json": { schema: body } },
                            },
                        }
                        : {})), { responses: {
                            [statusCode]: {
                                description: "Automatically added",
                                headers: Object.entries(responseHeaders || {}).reduce((a, b) => (Object.assign(Object.assign({}, a), { [b[0]]: {
                                        schema: b[1],
                                        required: true,
                                    } })), {}),
                                content: {
                                    [mediaType]: { schema: response },
                                },
                            },
                        } }) }),
            }
            : {};
        const newUrls = [{ url: baseUrl }];
        const newPaths = lodash_1.defaultsDeep(newPath, baseSchema.paths);
        const newServers = lodash_1.unionBy(newUrls.concat(baseSchema.servers || []), e => e.url);
        const finalSchema = Object.assign(Object.assign({}, baseSchema), { paths: newPaths, servers: newServers });
        return new ServiceCore({
            schema: finalSchema,
            name,
        });
    }
    get schema() {
        return this.oasSchema;
    }
    get hasDefinedPaths() {
        return this.hasPaths;
    }
    track(requestResponsePair) {
        this.callTracker.track(requestResponsePair);
    }
    get spy() {
        return this.callTracker.spy;
    }
}
exports.ServiceCore = ServiceCore;
//# sourceMappingURL=serviceCore.js.map