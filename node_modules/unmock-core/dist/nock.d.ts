import { JSONArray, JSONObject, JSONPrimitive, JSONSchemaObject, JSSTAllOf, JSSTAnyOf, JSSTAnything, JSSTEmpty, JSSTList, JSSTNot, JSSTObject, JSSTOneOf, JSSTTuple } from "json-schema-strictly-typed";
import { CodeAsInt } from "./interfaces";
import { Schema, ValidEndpointType } from "./service/interfaces";
import { ServiceStore } from "./service/serviceStore";
declare const DynamicJSONSymbol: unique symbol;
export interface IDynamicJSONValue {
    dynamic: typeof DynamicJSONSymbol;
}
declare const MaybeJSONSymbol: unique symbol;
export interface IMaybeJSONValue {
    maybe: typeof MaybeJSONSymbol;
    val: ExtendedValueType;
}
export declare type RecursiveUnionType = JSONPrimitive | JSONObject | JSONArray | IExtendedArrayType | IExtendedObjectType;
export declare type ExtendedJSONSchema = JSONSchemaObject<RecursiveUnionType, IDynamicJSONValue>;
export declare type ExtendedPrimitiveType = JSONPrimitive | ExtendedJSONSchema | RegExp;
export declare type ExtendedValueType = ExtendedPrimitiveType | IExtendedArrayType | IExtendedObjectType | JSONArray | JSONObject;
export interface ITameExtendedObjectType extends Record<string, ExtendedValueType> {
}
export interface IExtendedObjectType extends Record<string, ExtendedValueType | IMaybeJSONValue> {
}
export interface IExtendedArrayType extends Array<ExtendedValueType> {
}
declare type CType = string | number | boolean | null;
declare type ConstTransformer<T, C extends object> = (e: CType) => JSSTAnything<T, C>;
export declare const JSONSchemify: <T, C extends object>(c: C) => (schemaToSchemaTransformer: (schema: any) => JSSTAnything<T, C>) => (constantHandler: ConstTransformer<T, C>) => (e: ExtendedValueType) => JSSTAnything<T, C>;
export declare const u: {
    fuzz: (e: ExtendedValueType) => JSSTAnything<RecursiveUnionType, IDynamicJSONValue>;
    unfuzz: (e: ExtendedValueType) => JSSTAnything<RecursiveUnionType, IDynamicJSONValue>;
    opt: (e: JSONSchemaObject<RecursiveUnionType, IDynamicJSONValue>) => IMaybeJSONValue;
    nul: () => import("json-schema-strictly-typed").JSSTNull<IDynamicJSONValue>;
    cnst: (c: import("json-schema-strictly-typed").JSONValue) => import("json-schema-strictly-typed").JSSTConst<IDynamicJSONValue>;
    integer: (props?: import("json-schema-poet").IntPropsWithMinimum | import("json-schema-poet").IntPropsWithMaximum | import("json-schema-poet").IntPropsWithBounds | import("json-schema-poet").IntPropsWithExclusiveMinimum | import("json-schema-poet").IntPropsWithExclusiveMinimumAndMaximum | import("json-schema-poet").IntPropsWithExclusiveMaximum | import("json-schema-poet").IntPropsWithExclusiveMaximumAndMinimum | import("json-schema-poet").IntPropsWithExclusiveBounds | undefined) => import("json-schema-strictly-typed").JSSTInteger<IDynamicJSONValue>;
    number: (props?: Partial<import("json-schema-poet").NumberProps> | undefined) => import("json-schema-strictly-typed").JSSTNumber<IDynamicJSONValue>;
    string: (faker?: "address.zipCode" | "address.city" | "address.cityPrefix" | "address.citySuffix" | "address.streetName" | "address.streetAddress" | "address.streetSuffix" | "address.streetPrefix" | "address.secondaryAddress" | "address.county" | "address.country" | "address.countryCode" | "address.state" | "address.stateAbbr" | "address.latitude" | "address.longitude" | "commerce.color" | "commerce.department" | "commerce.productName" | "commerce.price" | "commerce.productAdjective" | "commerce.productMaterial" | "commerce.product" | "company.suffixes" | "company.companyName" | "company.companySuffix" | "company.catchPhrase" | "company.bs" | "company.catchPhraseAdjective" | "company.catchPhraseDescriptor" | "company.catchPhraseNoun" | "company.bsAdjective" | "company.bsBuzz" | "company.bsNoun" | "database.column" | "database.type" | "database.collation" | "database.engine" | "date.past" | "date.future" | "date.between" | "date.recent" | "date.soon" | "date.month" | "date.weekday" | "finance.account" | "finance.accountName" | "finance.mask" | "finance.amount" | "finance.transactionType" | "finance.currencyCode" | "finance.currencyName" | "finance.currencySymbol" | "finance.bitcoinAddress" | "finance.ethereumAddress" | "finance.iban" | "finance.bic" | "hacker.abbreviation" | "hacker.adjective" | "hacker.noun" | "hacker.verb" | "hacker.ingverb" | "hacker.phrase" | "helpers.randomize" | "helpers.slugify" | "helpers.replaceSymbolWithNumber" | "helpers.replaceSymbols" | "helpers.shuffle" | "helpers.mustache" | "helpers.createCard" | "helpers.contextualCard" | "helpers.userCard" | "helpers.createTransaction" | "image.image" | "image.avatar" | "image.imageUrl" | "image.abstract" | "image.animals" | "image.business" | "image.cats" | "image.city" | "image.food" | "image.nightlife" | "image.fashion" | "image.people" | "image.nature" | "image.sports" | "image.technics" | "image.transport" | "image.dataUri" | "internet.avatar" | "internet.email" | "internet.exampleEmail" | "internet.userName" | "internet.protocol" | "internet.url" | "internet.domainName" | "internet.domainSuffix" | "internet.domainWord" | "internet.ip" | "internet.ipv6" | "internet.userAgent" | "internet.color" | "internet.mac" | "internet.password" | "lorem.word" | "lorem.words" | "lorem.sentence" | "lorem.slug" | "lorem.sentences" | "lorem.paragraph" | "lorem.paragraphs" | "lorem.text" | "lorem.lines" | "name.firstName" | "name.lastName" | "name.findName" | "name.jobTitle" | "name.prefix" | "name.suffix" | "name.title" | "name.jobDescriptor" | "name.jobArea" | "name.jobType" | "phone.phoneNumber" | "phone.phoneNumberFormat" | "phone.phoneFormats" | "random.number" | "random.float" | "random.arrayElement" | "random.objectElement" | "random.uuid" | "random.boolean" | "random.word" | "random.words" | "random.image" | "random.locale" | "random.alphaNumeric" | "random.hexaDecimal" | "system.fileName" | "system.commonFileName" | "system.mimeType" | "system.commonFileType" | "system.commonFileExt" | "system.fileType" | "system.fileExt" | "system.directoryPath" | "system.filePath" | "system.semver" | undefined) => import("json-schema-strictly-typed").JSSTSimpleString<IDynamicJSONValue>;
    stringEnum: (enu: string[]) => import("json-schema-strictly-typed").JSSTStringEnum<IDynamicJSONValue>;
    numberEnum: (enu: number[]) => import("json-schema-strictly-typed").JSSTNumberEnum<IDynamicJSONValue>;
    integerEnum: (enu: number[]) => import("json-schema-strictly-typed").JSSTIntegerEnum<IDynamicJSONValue>;
    regex: (pattern: string) => import("json-schema-strictly-typed").JSSTRegex<IDynamicJSONValue>;
    boolean: () => import("json-schema-strictly-typed").JSSTBoolean<IDynamicJSONValue>;
    $ref: ($ref: string) => import("json-schema-strictly-typed").JSSTReference<IDynamicJSONValue>;
    array: (items: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>) => JSSTList<RecursiveUnionType, IDynamicJSONValue>;
    tuple: (items: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>[]) => JSSTTuple<RecursiveUnionType, IDynamicJSONValue>;
    allOf: (allOf: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>[]) => JSSTAllOf<RecursiveUnionType, IDynamicJSONValue>;
    anyOf: (anyOf: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>[]) => JSSTAnyOf<RecursiveUnionType, IDynamicJSONValue>;
    oneOf: (oneOf: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>[]) => JSSTOneOf<RecursiveUnionType, IDynamicJSONValue>;
    not: (not: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>) => JSSTNot<RecursiveUnionType, IDynamicJSONValue>;
    dictionary: (vals: JSSTAnything<RecursiveUnionType, IDynamicJSONValue>) => JSSTObject<RecursiveUnionType, IDynamicJSONValue>;
    type: (req: Record<string, JSSTAnything<RecursiveUnionType, IDynamicJSONValue>>, opt: Record<string, JSSTAnything<RecursiveUnionType, IDynamicJSONValue>>) => JSSTObject<RecursiveUnionType, IDynamicJSONValue>;
    object: (props?: Partial<import("json-schema-poet").ObjectProps<RecursiveUnionType, IDynamicJSONValue>> | undefined) => JSSTObject<RecursiveUnionType, IDynamicJSONValue>;
    top: <T_1, U_1 extends object, M extends JSSTAnything<T_1, U_1>>(anything: M, props?: import("json-schema-strictly-typed").JSSTTopLevel<T_1, U_1> | undefined) => JSONSchemaObject<T_1, U_1>;
    extend: <T_2, U_2 extends object>(what: JSSTAnything<T_2, U_2>, key: string, v: import("json-schema-strictly-typed").JSONValue) => JSONSchemaObject<T_2, U_2>;
};
declare type UpdateCallback = (store: ServiceStore) => (queriesFromCallToQueries: Record<string, Schema>) => ({ statusCode, data, headers, }: {
    statusCode: CodeAsInt | "default";
    headers: Record<string, Schema>;
    data: Schema;
}) => ServiceStore;
declare type Primitives = string | number | boolean;
declare type InputToPoet = {
    [k: string]: any;
} | Primitives | Primitives[];
export interface IFluentDynamicService {
    tldr(): void;
    get(endpoint: ValidEndpointType): DynamicServiceSpec;
    head(endpoint: ValidEndpointType): DynamicServiceSpec;
    post(endpoint: ValidEndpointType): DynamicServiceSpec;
    put(endpoint: ValidEndpointType): DynamicServiceSpec;
    patch(endpoint: ValidEndpointType): DynamicServiceSpec;
    delete(endpoint: ValidEndpointType): DynamicServiceSpec;
    options(endpoint: ValidEndpointType): DynamicServiceSpec;
    trace(endpoint: ValidEndpointType): DynamicServiceSpec;
}
interface IDynamicServiceSpec {
    query(data?: Record<string, InputToPoet>): IFluentDynamicService & IDynamicServiceSpec;
    reply(statusCode: CodeAsInt | "default", data?: InputToPoet | InputToPoet[], headers?: InputToPoet): IFluentDynamicService & IDynamicServiceSpec;
    reply(data: InputToPoet | InputToPoet[]): IFluentDynamicService & IDynamicServiceSpec;
}
export declare const vanillaJSONSchemify: (e: ExtendedValueType) => JSSTAnything<{
    [k: string]: never;
    [z: number]: never;
}, {}>;
export declare class DynamicServiceSpec implements IDynamicServiceSpec {
    private updater;
    private statusCode;
    private baseUrl;
    private accumulatedQueries;
    private requestHeaders;
    private serviceStore;
    private name?;
    private data;
    private headers;
    private queriesFromCallToQueries;
    constructor(updater: UpdateCallback, statusCode: CodeAsInt | "default", baseUrl: string, accumulatedQueries: Record<string, Schema>, requestHeaders: Record<string, JSSTAnything<JSSTEmpty<{}>, {}>>, serviceStore: ServiceStore, name?: string | undefined);
    query(data?: Record<string, InputToPoet>): IFluentDynamicService & IDynamicServiceSpec;
    reply(maybeStatusCode: CodeAsInt | "default" | InputToPoet | InputToPoet[], maybeData?: InputToPoet | InputToPoet[], maybeHeaders?: Record<string, InputToPoet>): IFluentDynamicService & IDynamicServiceSpec;
}
export declare const nockify: ({ serviceStore, baseUrl, requestHeaders, name, }: {
    serviceStore: ServiceStore;
    baseUrl: string;
    requestHeaders: Record<string, JSSTAnything<{
        [k: string]: never;
        [z: number]: never;
    }, {}>>;
    name?: string | undefined;
}) => IFluentDynamicService;
export {};
//# sourceMappingURL=nock.d.ts.map