"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const openapi_refinements_1 = require("openapi-refinements");
var openapi_refinements_2 = require("openapi-refinements");
exports.Arr = openapi_refinements_2.Arr;
exports.Addl = openapi_refinements_2.Addl;
const lodash_1 = require("lodash");
const codeConvert = (c) => `${c}`;
const withOrWithoutCodes = (withOrWithout) => (codes, path, method) => (_, o) => (withOrWithout ? openapi_refinements_1.includeCodes : openapi_refinements_1.removeCodes)(path !== undefined ? path : true, method !== undefined ? method : true, (codes instanceof Array ? codes : [codes]).map(codeConvert))(o);
const withCodes = withOrWithoutCodes(true);
const withoutCodes = withOrWithoutCodes(false);
const mapDefaultTo = (codes, path, method) => (_, o) => openapi_refinements_1.mapDefaultToCodes(path !== undefined ? path : true, method !== undefined ? method : true, (codes instanceof Array ? codes : [codes]).map(codeConvert))(o);
const pathParameterSignatureFromOptions = (options) => [
    options && options.path !== undefined ? options.path : true,
    options && options.name !== undefined ? options.name : true,
    options && options.in !== undefined ? options.in : true,
];
const methodParameterSignatureFromOptions = (options) => [
    options && options.path !== undefined ? options.path : true,
    options && options.method !== undefined ? options.method : true,
    options && options.name !== undefined ? options.name : true,
    options && options.in !== undefined ? options.in : true,
];
const headerSignatureFromOptions = (options) => [
    options && options.path !== undefined ? options.path : true,
    options && options.method !== undefined ? options.method : true,
    options && options.code !== undefined
        ? typeof options.code === "boolean"
            ? options.code
            : (options.code instanceof Array ? options.code : [options.code]).map(codeConvert)
        : true,
    options && options.name !== undefined ? options.name : true,
];
const responseBodySignatureFromOptions = (options) => [
    options && options.path !== undefined ? options.path : true,
    options && options.method !== undefined ? options.method : true,
    options && options.code !== undefined
        ? typeof options.code === "boolean"
            ? options.code
            : (options.code instanceof Array ? options.code : [options.code]).map(codeConvert)
        : true,
    options && options.mediaTypes !== undefined
        ? typeof options.mediaTypes === "string"
            ? [options.mediaTypes]
            : options.mediaTypes
        : true,
];
const requestBodySignatureFromOptions = (options) => [
    options && options.path !== undefined ? options.path : true,
    options && options.method !== undefined ? options.method : true,
    options && options.mediaTypes !== undefined
        ? typeof options.mediaTypes === "string"
            ? [options.mediaTypes]
            : options.mediaTypes
        : true,
];
const expandCurriedTraversal = (c, options) => (tf) => (_, o) => c(tf(options), options && options.lens ? options.lens : [])(o);
const makeSchemaTraversalStructure = (tf) => (options) => ({
    const: (j) => expandCurriedTraversal(openapi_refinements_1.changeToConst(j), options)(tf),
    minItems: (i) => expandCurriedTraversal(openapi_refinements_1.changeMinItems(i), options)(tf),
    maxItems: (i) => expandCurriedTraversal(openapi_refinements_1.changeMaxItems(i), options)(tf),
    required: (prop) => expandCurriedTraversal(openapi_refinements_1.changeRequiredStatus(prop), options)(tf),
    enumKeep: (vals) => expandCurriedTraversal(openapi_refinements_1.changeEnum(vals, true), options)(tf),
    enumReject: (vals) => expandCurriedTraversal(openapi_refinements_1.changeEnum(vals, false), options)(tf),
    anyOfKeep: (indices) => expandCurriedTraversal(openapi_refinements_1.anyOfKeep(indices), options)(tf),
    anyOfReject: (indices) => expandCurriedTraversal(openapi_refinements_1.anyOfReject(indices), options)(tf),
    oneOfKeep: (indices) => expandCurriedTraversal(openapi_refinements_1.oneOfKeep(indices), options)(tf),
    oneOfReject: (indices) => expandCurriedTraversal(openapi_refinements_1.oneOfReject(indices), options)(tf),
    listToTuple: (i) => expandCurriedTraversal(openapi_refinements_1.changeListToTuple(i), options)(tf),
    schema: (schemaOrFunction) => expandCurriedTraversal(openapi_refinements_1.changeSingleSchema(typeof schemaOrFunction === "function"
        ? schemaOrFunction
        : (_) => (__) => schemaOrFunction), options)(tf),
});
exports.transform = {
    compose: (...transformers) => (req, o) => transformers.reduce((a, b) => b(req, a), o),
    noopThrows: (f) => (req, o) => {
        const out = f(req, o);
        if (lodash_1.isEqual(out, o)) {
            throw Error("Array item setting did not work");
        }
        return out;
    },
    times: (n) => (f) => {
        let counter = 0;
        return (req, o) => {
            const out = f(req, o);
            if (!lodash_1.isEqual(out, o)) {
                counter += 1;
            }
            if (counter > n) {
                return o;
            }
            return out;
        };
    },
    after: (n) => (f) => {
        let counter = 0;
        return (req, o) => {
            const out = f(req, o);
            if (!lodash_1.isEqual(out, o)) {
                counter += 1;
            }
            if (counter <= n) {
                return o;
            }
            return out;
        };
    },
    withCodes,
    withoutCodes,
    mapDefaultTo,
    responseBody: makeSchemaTraversalStructure((options) => openapi_refinements_1.responseBody(...responseBodySignatureFromOptions(options))),
    requestBody: makeSchemaTraversalStructure((options) => openapi_refinements_1.requestBody(...requestBodySignatureFromOptions(options))),
    pathParameter: makeSchemaTraversalStructure((options) => openapi_refinements_1.pathParameter(...pathParameterSignatureFromOptions(options))),
    methodParameter: makeSchemaTraversalStructure((options) => openapi_refinements_1.methodParameter(...methodParameterSignatureFromOptions(options))),
    header: makeSchemaTraversalStructure((options) => openapi_refinements_1.header(...headerSignatureFromOptions(options))),
};
//# sourceMappingURL=generator-utils.js.map