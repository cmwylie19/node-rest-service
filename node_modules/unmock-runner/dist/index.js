"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const defaultRunnerOptions = {
    maxLoop: 20,
};
const errorHandler = (nTimes, errors, intermediaryErrors, cb) => {
    const msg = (rest) => `This many tests failed: ${errors.length +
        intermediaryErrors.length} out of ${nTimes}. Here's the first error.\n${rest}`;
    if (errors.length) {
        errors[0].message = msg(errors[0].message);
    }
    else {
        intermediaryErrors[0] =
            typeof intermediaryErrors[0] === "string"
                ? msg(intermediaryErrors[0])
                : {
                    message: msg(intermediaryErrors[0].message),
                };
    }
    if (cb) {
        cb.fail(intermediaryErrors.length ? intermediaryErrors[0] : errors[0].message);
    }
    else {
        throw errors[0];
    }
};
exports.default = (assertionValidator) => (unmockPackage) => (fn, options) => (cb) => __awaiter(void 0, void 0, void 0, function* () {
    const realOptions = Object.assign(Object.assign({}, defaultRunnerOptions), options);
    const intermediaryErrors = [];
    const intermediaryDoneCallback = {
        success: () => {
        },
        fail: () => { },
    };
    intermediaryDoneCallback.fail = (error) => {
        intermediaryErrors.push(error);
    };
    const errors = [];
    const res = [];
    for (let i = 0; i < realOptions.maxLoop; i++) {
        unmockPackage.backend.faker.randomNumberGenerator.setSeed(i);
        unmockPackage.backend.faker.optionalsProbability = Math.random();
        unmockPackage.backend.faker.minItems = Math.floor(Math.random() * Math.pow(2, (i % 5)));
        try {
            const r = yield (fn ? fn(intermediaryDoneCallback) : undefined);
            res.push(r);
        }
        catch (e) {
            if (assertionValidator(e)) {
                errors.push(e);
            }
            else {
                throw e;
            }
        }
        finally {
            Object.entries(unmockPackage.backend.serviceStore.services).forEach(([_, service]) => {
                service.spy.resetHistory();
            });
        }
        unmockPackage.backend.faker.optionalsProbability = 1.0;
        unmockPackage.backend.faker.minItems = 0;
    }
    if (errors.length + intermediaryErrors.length > 0) {
        errorHandler(realOptions.maxLoop, errors, intermediaryErrors, cb);
    }
    else {
        cb && cb.success();
    }
});
//# sourceMappingURL=index.js.map